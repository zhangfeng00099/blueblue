<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas ğŸ„</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden !important;
            background: #000;
            font-family: Arial, sans-serif;
            cursor: grab;
            position: fixed;
            left: 0;
            top: 0;
        }

        body {
            position: relative;
        }



        .reset-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            z-index: 100;
            display: none;
            /* åˆå§‹éšè—ï¼Œåªåœ¨æ˜Ÿç©ºæ¨¡å¼ä¸‹æ˜¾ç¤º */
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .starfield-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .starfield-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .starfield-btn:active {
            transform: translateY(-1px);
        }

        .star-icon {
            font-size: 20px;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        body:active {
            cursor: grabbing;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .title {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 3em;
            font-weight: bold;
            line-height: 1.2;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 215, 0, 0.4);
            z-index: 100;
            pointer-events: none;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 215, 0, 0.4);
            }

            to {
                text-shadow: 0 0 25px rgba(255, 215, 0, 0.9), 0 0 50px rgba(255, 215, 0, 0.7), 0 0 75px rgba(255, 215, 0, 0.5);
            }
        }

        .photo-frame {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 280px;
            height: 350px;
            border: 10px solid #FFD700;
            border-radius: 8px;
            background: #fff;
            padding: 12px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 50;
            display: none;
            opacity: 0;
        }

        .photo-frame.show {
            display: block;
        }

        .photo-frame.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .photo-frame.angle-1 {
            transform: translate(-50%, -50%) scale(1) rotate(-3deg);
        }

        .photo-frame.angle-2 {
            transform: translate(-50%, -50%) scale(1) rotate(3deg);
        }

        .photo-frame.angle-3 {
            transform: translate(-50%, -50%) scale(1) rotate(-4deg);
        }

        .photo-frame.angle-4 {
            transform: translate(-50%, -50%) scale(1) rotate(4deg);
        }

        /* å¯†ç é”æ ·å¼ */
        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a0a0a 0%, #050505 100%);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            /* ç§»åˆ°åº•éƒ¨ */
            z-index: 10000;
            /* ç¡®ä¿åœ¨æœ€é¡¶å±‚ */
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        #overlay-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #password-overlay.unlocked {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.1);
        }

        /* å¯†ç å®¹å™¨ */
        .password-container {
            text-align: center;
            padding: 20px 25px 15px 25px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.01) 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow:
                0 20px 50px rgba(0, 0, 0, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.05);
            width: 280px;
            z-index: 10;
            transition: all 1.2s cubic-bezier(0.19, 1, 0.22, 1);
            position: relative;
            margin-bottom: 27vh;
        }

        .password-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.05) 40%, transparent 50%, rgba(255, 255, 255, 0.1));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
        }

        .password-container.morph-to-heart {
            width: 180px;
            height: 180px;
            padding: 0;
            margin-bottom: 40vh;
            /* å˜æˆçˆ±å¿ƒåç§»å‘å±å¹•ä¸­é—´ */
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            box-shadow:
                0 0 50px rgba(255, 0, 0, 0.8),
                inset 0 0 30px rgba(0, 0, 0, 0.5);
            border: none;
            clip-path: path('M90 155c-50-35-85-70-85-105 0-35 25-60 60-60 20 0 35 15 45 30 10-15 25-30 45-30 35 0 60 25 60 60 0 35-35 70-85 105z');
            transition: all 1.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            animation: heartFloat 3s ease-in-out infinite;
        }

        @keyframes heartFloat {

            0%,
            100% {
                transform: translateY(0) scale(1);
                filter: drop-shadow(0 0 20px rgba(255, 0, 0, 0.6));
            }

            50% {
                transform: translateY(-15px) scale(1.05);
                filter: drop-shadow(0 0 40px rgba(255, 0, 0, 0.9));
            }
        }

        .password-container.morph-to-heart * {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s;
        }

        .heart-submit {
            font-size: 45px;
            cursor: pointer;
            display: inline-block;
            filter: drop-shadow(0 0 15px rgba(255, 51, 51, 0.8));
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: heartBeat 2s infinite cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            margin-top: 10px;
        }

        .heart-submit:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 25px rgba(255, 51, 51, 1));
        }

        .heart-submit:active {
            transform: scale(0.9);
        }

        @keyframes heartBeat {

            0%,
            100% {
                transform: scale(1);
                filter: drop-shadow(0 0 15px rgba(255, 51, 51, 0.8));
            }

            50% {
                transform: scale(1.1);
                filter: drop-shadow(0 0 25px rgba(255, 51, 51, 1));
            }
        }

        .input-wrapper {
            position: relative;
            margin-bottom: 5px;
        }

        #password-input {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            color: #fff;
            font-size: 16px;
            text-align: center;
            outline: none;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            letter-spacing: 5px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #password-input:focus {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow:
                0 0 20px rgba(255, 255, 255, 0.05),
                inset 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }

        #password-input::placeholder {
            color: rgba(255, 255, 255, 0.2);
            letter-spacing: 2px;
        }

        #password-error {
            color: #ff4d4d;
            font-size: 13px;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            height: 20px;
            margin-bottom: 5px;
            transform: translateY(5px);
            filter: drop-shadow(0 0 5px rgba(255, 77, 77, 0.3));
        }

        #password-error.show {
            opacity: 1;
            transform: translateY(0);
        }

        .photo-frame.angle-5 {
            transform: translate(-50%, -50%) scale(1) rotate(-2deg);
        }

        .photo-frame.angle-6 {
            transform: translate(-50%, -50%) scale(1) rotate(2deg);
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 2px;
        }

        .close-btn {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background: #ff6b6b;
            border: 2px solid #fff;
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            line-height: 26px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .close-btn:hover {
            background: #ff5252;
        }

        .hint {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
        }

        .gift-click-zone {
            position: absolute;
            width: 80px;
            height: 80px;
            background: transparent;
            cursor: pointer;
            z-index: 50;
            /* é™ä½ z-indexï¼Œä½¿å…¶åœ¨å¯†ç å±‚ä¹‹ä¸‹ */
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .gift-click-zone:hover {
            transform: scale(1.1);
        }

        .gift-click-zone::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.1;
            }
        }

        .letter-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 200;
            display: none;
            opacity: 0;
            width: 85%;
            max-width: 320px;
            /* å‡å°å®½åº¦ï¼Œé€‚åˆçŸ­å¥ */
        }

        .letter-popup.show {
            display: block;
        }

        .letter-popup.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .letter-content {
            background: #fff9f0;
            border: 2px solid #d4a76a;
            border-radius: 20px;
            /* æ›´åœ†æ¶¦çš„è¾¹è§’ */
            padding: 40px 25px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
            text-align: center;
            /* æ–‡å­—å±…ä¸­ */
            position: relative;
            background-image: radial-gradient(#d4a76a 0.5px, transparent 0.5px);
            /* æç»†çš„ç‚¹çŠ¶åº•çº¹ */
            background-size: 20px 20px;
        }

        .letter-header {
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
            filter: drop-shadow(1px 2px 3px rgba(0, 0, 0, 0.1));
            position: relative;
            z-index: 1;
        }

        .letter-text {
            font-size: 18px;
            /* ç¨å¾®åŠ å¤§å­—ä½“ */
            color: #4a3728;
            font-family: "Kaiti", "STKaiti", "æ¥·ä½“", "STXingkai", "åæ–‡è¡Œæ¥·", serif;
            font-weight: bold;
            /* åŠ ç²—ä¸€ç‚¹æ›´æ˜¾è¯šæ„ */
            letter-spacing: 1px;
            text-shadow: none;
            line-height: 1.8;
            position: relative;
            z-index: 1;
            min-height: 1.6em;
            white-space: pre-wrap;
            word-break: break-all;
            display: inline-block;
            /* é…åˆå±…ä¸­ */
        }

        /* æ‰“å­—æœºå…‰æ ‡æ•ˆæœ */
        .letter-text::after {
            content: '|';
            display: inline-block;
            margin-left: 5px;
            animation: blink 0.8s infinite;
            font-weight: 100;
            color: #4a3728;
            opacity: 0.7;
        }

        .letter-text.typing-done::after {
            display: none;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 0;
            }

            50% {
                opacity: 0.7;
            }
        }

        @keyframes textGlow {
            from {
                text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.05);
            }

            to {
                text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.1);
            }
        }

        .letter-close {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #c9a66b 0%, #a67c52 100%);
            border: 2px solid #8b5a2b;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            font-family: Arial, sans-serif;
            z-index: 210;
        }

        .letter-close:hover {
            background: linear-gradient(135deg, #d4b078 0%, #b8895a 100%);
            transform: scale(1.15) rotate(90deg);
        }
    </style>
</head>

<body>

    <!-- å¯†ç é” -->
    <div id="password-overlay">
        <div id="overlay-canvas-container"></div>
        <div class="password-container">
            <div class="input-wrapper">
                <input type="password" id="password-input" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" maxlength="8" autocomplete="off">
            </div>
            <div id="password-error">å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•</div>
            <div id="password-submit" class="heart-submit">â¤ï¸</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <div class="title">Merry<br>Christmas</div>
    <div class="photo-frame" id="photoFrame">
        <div class="close-btn" id="closeBtn">Ã—</div>
        <img id="photoImg" src="" alt="Photo">
    </div>

    <div class="letter-popup" id="letterPopup">
        <div class="letter-close" id="letterClose">Ã—</div>
        <div class="letter-content">
            <div class="letter-header">ğŸ“ƒ</div>
            <div class="letter-text"></div>
        </div>
    </div>

    <!-- <div class="hint">æ‹–æ‹½æ—‹è½¬ ç‚¹å‡»ç¤¼ç‰©</div> -->

    <!-- ç¤¼ç›’é€æ˜ç‚¹å‡»æ¡† -->
    <div class="gift-click-zone" id="giftClick1" onclick="openGroundGift3D(1)"></div>
    <div class="gift-click-zone" id="giftClick2" onclick="openGroundGift3D(2)"></div>
    <div class="gift-click-zone" id="giftClick3" onclick="openGroundGift3D(3)"></div>
    <div class="gift-click-zone" id="giftClick4" onclick="openGroundGift3D(4)"></div>







    <script>


        // åœºæ™¯è®¾ç½®
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.display = 'block';
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.physicallyCorrectLights = true; // ä½¿ç”¨ç‰©ç†æ­£ç¡®çš„å…‰ç…§è®¡ç®—
        renderer.outputEncoding = THREE.sRGBEncoding; // ä½¿ç”¨sRGBç¼–ç è¾“å‡º
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // ä½¿ç”¨ACESèƒ¶ç‰‡è‰²è°ƒæ˜ å°„
        renderer.toneMappingExposure = 0.8; // é™ä½æ›å…‰åº¦ï¼Œå‡å°‘åˆºçœ¼æ•ˆæœ
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ç›¸æœºä½ç½®
        camera.position.z = 5;

        // åˆ›å»ºæ–¹å½¢ç²’å­çº¹ç†
        function createSquareTexture(color) {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // ç»˜åˆ¶æ–¹å½¢ï¼Œå¸¦æ›´æŸ”å’Œçš„å‘å…‰æ•ˆæœï¼ˆé™ä½äº®åº¦ï¼‰
            const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.2, color + 'EE');
            gradient.addColorStop(0.4, color + 'DD');
            gradient.addColorStop(0.6, color + 'AA');
            gradient.addColorStop(0.8, color + '55');
            gradient.addColorStop(1, color + '00');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            // æ·»åŠ æ¸…æ™°çš„æ–¹å½¢æ ¸å¿ƒï¼Œä½†æ›´æŸ”å’Œ
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = color;
            const padding = size * 0.35;
            ctx.fillRect(padding, padding, size - padding * 2, size - padding * 2);
            ctx.globalAlpha = 1.0;

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // åˆ›å»ºåœ†å½¢ç²’å­çº¹ç†ï¼ˆç”¨äºç¤¼ç‰©ï¼‰- æŸ”å’Œç‰ˆæœ¬
        function createCircleTexture(color) {
            const size = 256; // æé«˜çº¹ç†åˆ†è¾¨ç‡
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºæ›´æŸ”å’Œçš„å¾„å‘æ¸å˜ï¼Œå‡å°‘çªå…€æ„Ÿ
            const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.15, color + 'EE');
            gradient.addColorStop(0.3, color + 'BB');
            gradient.addColorStop(0.5, color + '77');
            gradient.addColorStop(0.7, color + '33');
            gradient.addColorStop(0.85, color + '11');
            gradient.addColorStop(1, color + '00');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();

            // æ·»åŠ æ›´æŸ”å’Œçš„å†…éƒ¨é«˜å…‰æ•ˆæœ
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1.0;

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // å¯ç”¨çº¹ç†è°ƒè¯•ï¼ˆåœ¨æµè§ˆå™¨æ§åˆ¶å°ä¸­è¾“å…¥ debugTexture = trueï¼‰
        window.debugTexture = false;

        // è°ƒæ•´é¢œè‰²äº®åº¦çš„è¾…åŠ©å‡½æ•°
        function adjustBrightness(hexColor, percent) {
            const num = parseInt(hexColor.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        // ç»˜åˆ¶å°æ˜Ÿæ˜Ÿ
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        // ç»˜åˆ¶å°é›ªèŠ±
        function drawSnowflake(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            for (let i = 0; i < 6; i++) {
                ctx.rotate(Math.PI / 3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -size);
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.stroke();

                // æ·»åŠ å°åˆ†æ”¯
                ctx.beginPath();
                ctx.moveTo(0, -size * 0.6);
                ctx.lineTo(-size * 0.2, -size * 0.8);
                ctx.moveTo(0, -size * 0.6);
                ctx.lineTo(size * 0.2, -size * 0.8);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ç»˜åˆ¶èŠ±æœµ
        function drawFlower(ctx, cx, cy, radius) {
            ctx.save();
            ctx.translate(cx, cy);

            // ç»˜åˆ¶5ä¸ªèŠ±ç“£
            for (let i = 0; i < 5; i++) {
                ctx.rotate(Math.PI * 2 / 5);
                ctx.beginPath();
                ctx.ellipse(0, radius * 0.6, radius * 0.4, radius * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // ç»˜åˆ¶èŠ±å¿ƒ
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#FFD700';
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶æ¾æœ
        function drawPinecone(ctx, cx, cy, size) {
            ctx.save();
            ctx.translate(cx, cy);

            // æ¾æœä¸»ä½“
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < 5; i++) {
                const y = -size * 0.4 + i * size * 0.2;
                const width = size * (0.3 - i * 0.04);
                ctx.beginPath();
                ctx.ellipse(0, y, width, size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // æ¾æœé¡¶éƒ¨
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(0, -size * 0.5, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶åœ£è¯ç³–æœ cane
        function drawCandyCane(ctx, cx, cy, size) {
            ctx.save();
            ctx.translate(cx, cy);

            // ç³–æœ cane ä¸»ä½“
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = size * 0.15;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, size * 0.5);
            ctx.lineTo(0, -size * 0.2);
            ctx.arc(size * 0.2, -size * 0.2, size * 0.2, Math.PI, Math.PI * 1.5);
            ctx.stroke();

            // ç™½è‰²æ¡çº¹
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = size * 0.08;
            ctx.beginPath();
            ctx.moveTo(0, size * 0.4);
            ctx.lineTo(0, -size * 0.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(size * 0.2, -size * 0.2, size * 0.2, Math.PI, Math.PI * 1.5);
            ctx.stroke();

            ctx.restore();
        }

        // ç»˜åˆ¶åœ£è¯èŠ±ç¯
        function drawWreath(ctx, cx, cy, size) {
            ctx.save();
            ctx.translate(cx, cy);

            // èŠ±ç¯ä¸»ä½“
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 36; i++) {
                const angle = (i / 36) * Math.PI * 2;
                const x = Math.cos(angle) * size * 0.5;
                const y = Math.sin(angle) * size * 0.5;
                ctx.beginPath();
                ctx.arc(x, y, size * 0.12, 0, Math.PI * 2);
                ctx.fill();
            }

            // çº¢è‰²æµ†æœè£…é¥°
            ctx.fillStyle = '#DC143C';
            const berryPositions = [
                { x: 0, y: -size * 0.5 },
                { x: size * 0.35, y: -size * 0.35 },
                { x: size * 0.5, y: 0 },
                { x: size * 0.35, y: size * 0.35 },
                { x: 0, y: size * 0.5 },
                { x: -size * 0.35, y: size * 0.35 },
                { x: -size * 0.5, y: 0 },
                { x: -size * 0.35, y: -size * 0.35 }
            ];
            berryPositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
            });

            // é‡‘è‰²ä¸å¸¦
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(-size * 0.15, -size * 0.5);
            ctx.lineTo(size * 0.15, -size * 0.5);
            ctx.lineTo(size * 0.25, -size * 0.7);
            ctx.lineTo(-size * 0.25, -size * 0.7);
            ctx.closePath();
            ctx.fill();

            // ä¸å¸¦å°¾éƒ¨
            ctx.beginPath();
            ctx.moveTo(-size * 0.1, -size * 0.7);
            ctx.lineTo(-size * 0.15, -size * 0.9);
            ctx.lineTo(-size * 0.05, -size * 0.7);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(size * 0.1, -size * 0.7);
            ctx.lineTo(size * 0.15, -size * 0.9);
            ctx.lineTo(size * 0.05, -size * 0.7);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶å†¬é’å¶
        function drawHollyLeaf(ctx, cx, cy, size, rotation) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(rotation);

            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.5);
            ctx.quadraticCurveTo(size * 0.3, -size * 0.3, size * 0.4, 0);
            ctx.quadraticCurveTo(size * 0.3, size * 0.3, 0, size * 0.5);
            ctx.quadraticCurveTo(-size * 0.3, size * 0.3, -size * 0.4, 0);
            ctx.quadraticCurveTo(-size * 0.3, -size * 0.3, 0, -size * 0.5);
            ctx.fill();

            // å¶è„‰
            ctx.strokeStyle = '#1A5F1A';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.4);
            ctx.lineTo(0, size * 0.4);
            ctx.stroke();

            ctx.restore();
        }

        // ç»˜åˆ¶åœ£è¯å½©å¸¦
        function drawRibbon(ctx, x1, y1, x2, y2, width, color) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }

        // ç»˜åˆ¶åœ£è¯è€äºº
        function drawSantaClaus(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // èº«ä½“ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // è„¸éƒ¨ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, -size * 0.3, size * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // å¸½å­ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.moveTo(-size * 0.4, -size * 0.5);
            ctx.lineTo(size * 0.4, -size * 0.5);
            ctx.lineTo(0, -size * 1.2);
            ctx.closePath();
            ctx.fill();

            // å¸½å­ä¸Šçš„æ¯›çƒï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, -size * 1.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // èƒ¡é¡»ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, size * 0.1, size * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // çœ¼ç›ï¼ˆé»‘è‰²ï¼‰
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-size * 0.15, -size * 0.35, size * 0.05, 0, Math.PI * 2);
            ctx.arc(size * 0.15, -size * 0.35, size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶éº‹é¹¿
        function drawReindeer(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // èº«ä½“ï¼ˆæ£•è‰²ï¼‰
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(0, 0, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // å¤´éƒ¨
            ctx.beginPath();
            ctx.arc(size * 0.5, -size * 0.2, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // è…¿
            ctx.fillRect(-size * 0.5, size * 0.2, size * 0.15, size * 0.4);
            ctx.fillRect(-size * 0.1, size * 0.2, size * 0.15, size * 0.4);
            ctx.fillRect(size * 0.1, size * 0.2, size * 0.15, size * 0.4);
            ctx.fillRect(size * 0.5, size * 0.2, size * 0.15, size * 0.4);

            // é¹¿è§’ï¼ˆæ£•è‰²ï¼‰
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            // å·¦è§’
            ctx.moveTo(size * 0.4, -size * 0.3);
            ctx.lineTo(size * 0.3, -size * 0.6);
            ctx.lineTo(size * 0.2, -size * 0.5);
            ctx.moveTo(size * 0.3, -size * 0.6);
            ctx.lineTo(size * 0.25, -size * 0.8);
            // å³è§’
            ctx.moveTo(size * 0.6, -size * 0.3);
            ctx.lineTo(size * 0.7, -size * 0.6);
            ctx.lineTo(size * 0.8, -size * 0.5);
            ctx.moveTo(size * 0.7, -size * 0.6);
            ctx.lineTo(size * 0.75, -size * 0.8);
            ctx.stroke();

            // é¼»å­ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.arc(size * 0.6, -size * 0.2, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶é›ªèŠ±
        function drawSnowflake(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // ç»˜åˆ¶å…­è§’é›ªèŠ±
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = size / 6;
            ctx.lineCap = 'round';

            for (let i = 0; i < 6; i++) {
                ctx.rotate(Math.PI / 3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, size);
                ctx.stroke();

                // æ·»åŠ å°åˆ†æ”¯
                ctx.beginPath();
                ctx.moveTo(0, size * 0.5);
                ctx.lineTo(size * 0.3, size * 0.3);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, size * 0.5);
                ctx.lineTo(-size * 0.3, size * 0.3);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ç»˜åˆ¶å†¬é’å¶
        function drawHollyLeaf(ctx, x, y, size, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-size * 0.5, -size * 0.5, -size * 0.3, -size);
            ctx.quadraticCurveTo(0, -size * 0.7, size * 0.3, -size);
            ctx.quadraticCurveTo(size * 0.5, -size * 0.5, 0, 0);
            ctx.fill();
            ctx.restore();
        }

        // ç»˜åˆ¶åœ£è¯æ ‘
        function drawChristmasTree(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // æ ‘å¹²
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-size * 0.1, 0, size * 0.2, size * 0.3);

            // æ ‘å†  - ä¸‰å±‚ä¸‰è§’å½¢
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 3; i++) {
                const layerY = -size * 0.1 - i * size * 0.3;
                const layerWidth = size * (0.8 - i * 0.2);
                ctx.beginPath();
                ctx.moveTo(0, layerY - size * 0.4);
                ctx.lineTo(-layerWidth / 2, layerY);
                ctx.lineTo(layerWidth / 2, layerY);
                ctx.closePath();
                ctx.fill();
            }

            // æ ‘é¡¶æ˜Ÿæ˜Ÿ
            ctx.fillStyle = '#FFD700';
            drawStar(ctx, 0, -size * 1.2, 5, size * 0.15, size * 0.07);

            // æ ‘ä¸Šè£…é¥° - å½©è‰²åœ†ç‚¹
            const decorations = [
                { x: -size * 0.2, y: -size * 0.3, color: '#FF0000' },
                { x: size * 0.2, y: -size * 0.3, color: '#FFD700' },
                { x: -size * 0.15, y: -size * 0.5, color: '#FFD700' },
                { x: size * 0.15, y: -size * 0.5, color: '#FF0000' },
                { x: 0, y: -size * 0.7, color: '#FFFFFF' }
            ];
            decorations.forEach(deco => {
                ctx.fillStyle = deco.color;
                ctx.beginPath();
                ctx.arc(deco.x, deco.y, size * 0.05, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // ç»˜åˆ¶é“ƒé“›
        function drawBell(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // é“ƒé“›ä¸»ä½“
            ctx.beginPath();
            ctx.arc(0, 0, size, Math.PI, 0, false);
            ctx.lineTo(size, size * 0.3);
            ctx.quadraticCurveTo(0, size * 0.5, -size, size * 0.3);
            ctx.closePath();
            ctx.fill();

            // é“ƒé“›é¡¶éƒ¨
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // é“ƒé“›åº•éƒ¨å°åœ†
            ctx.beginPath();
            ctx.arc(0, size * 0.35, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // åˆ›å»ºç²¾ç¾åœ£è¯èŠ‚ç¤¼ç‰©ç›’å­çº¹ç† - ä½¿ç”¨å½©è‰²åŒ…è£…çº¸æ•ˆæœ
        function createGiftBoxTexture(color) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºå½©è‰²åŒ…è£…çº¸èƒŒæ™¯ - ä½¿ç”¨æ›´é²œè‰³çš„é¢œè‰²
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, size, size);

            // æ·»åŠ åŒ…è£…çº¸çº¹ç†å›¾æ¡ˆ - ä½¿ç”¨å›ºå®šç§å­ç¡®ä¿ä¸€è‡´æ€§
            ctx.strokeStyle = adjustBrightness(color, -30);
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;

            // æ·»åŠ ç½‘æ ¼çº¹ç†
            for (let i = 0; i < size; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(size, i);
                ctx.stroke();
            }

            // æ·»åŠ å›ºå®šä½ç½®çš„é›ªèŠ±å›¾æ¡ˆ
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = '#FFFFFF';
            const snowflakePositions = [
                { x: 30, y: 30 }, { x: 100, y: 50 }, { x: 170, y: 40 }, { x: 220, y: 60 },
                { x: 50, y: 120 }, { x: 130, y: 140 }, { x: 200, y: 110 }, { x: 80, y: 200 }
            ];
            snowflakePositions.forEach(pos => {
                drawSnowflake(ctx, pos.x, pos.y, 8);
            });

            // æ·»åŠ å›ºå®šä½ç½®çš„æ˜Ÿæ˜Ÿå›¾æ¡ˆ
            const starPositions = [
                { x: 60, y: 80 }, { x: 150, y: 90 }, { x: 210, y: 170 },
                { x: 40, y: 160 }, { x: 120, y: 180 }, { x: 180, y: 220 }
            ];
            starPositions.forEach(pos => {
                drawStar(ctx, pos.x, pos.y, 5, 10, 5);
            });

            ctx.globalAlpha = 1.0;

            // æ·»åŠ å…‰æ³½æ•ˆæœ
            const shineGradient = ctx.createLinearGradient(0, 0, size, size);
            shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            shineGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.3)');
            shineGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
            shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = shineGradient;
            ctx.fillRect(0, 0, size, size);

            // æ·»åŠ æ›´å®½çš„è£…é¥°å¸¦ - ä½¿ç”¨é‡‘è‰²å¢å¼ºå–œåº†æ„Ÿ
            ctx.strokeStyle = '#FFD700'; // é‡‘è‰²è£…é¥°å¸¦
            ctx.lineWidth = size * 0.08; // å¢åŠ è£…é¥°å¸¦å®½åº¦
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();

            // æ·»åŠ æ›´ç²¾ç¾çš„è´è¶ç»“ - ä½¿ç”¨é‡‘è‰²å¢å¼ºèŠ‚æ—¥æ°”æ°›
            ctx.fillStyle = '#FFD700';

            // è´è¶ç»“å·¦ç¿¼
            ctx.beginPath();
            ctx.ellipse(size / 2 - size * 0.08, size / 2, size * 0.12, size * 0.06, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            // è´è¶ç»“å³ç¿¼
            ctx.beginPath();
            ctx.ellipse(size / 2 + size * 0.08, size / 2, size * 0.12, size * 0.06, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            // è´è¶ç»“ä¸­å¿ƒ
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // æ·»åŠ å°æ˜Ÿæ˜Ÿè£…é¥°
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < 5; i++) {
                const x = (i + 1) * size / 6;
                const y = size / 6;
                drawStar(ctx, x, y, 5, size * 0.03, size * 0.015);
            }

            // æ·»åŠ é›ªèŠ±è£…é¥°
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < 4; i++) {
                const x = (i + 1) * size / 5;
                const y = size * 5 / 6;
                drawSnowflake(ctx, x, y, size * 0.02);
            }

            // æ·»åŠ å°é“ƒé“›è£…é¥°
            ctx.fillStyle = '#FFD700';
            for (let i = 0; i < 3; i++) {
                const x = size * (0.2 + i * 0.3);
                const y = size * 0.8;
                ctx.beginPath();
                ctx.arc(x, y, size * 0.02, 0, Math.PI * 2);
                ctx.fill();

                // é“ƒé“›æŠŠæ‰‹
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - size * 0.01, y - size * 0.02);
                ctx.lineTo(x + size * 0.01, y - size * 0.02);
                ctx.stroke();
            }

            // æ·»åŠ å†¬é’å¶è£…é¥°
            ctx.fillStyle = '#0F7B0F'; // æ£®æ—ç»¿
            for (let i = 0; i < 3; i++) {
                const x = size * (0.15 + i * 0.7);
                const y = size * 0.15;
                drawHollyLeaf(ctx, x, y, size * 0.04);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            // è°ƒè¯•ï¼šå°†canvasæ·»åŠ åˆ°é¡µé¢ä»¥éªŒè¯çº¹ç†æ˜¯å¦æ­£ç¡®åˆ›å»º
            if (window.debugTexture) {
                const debugImg = document.createElement('img');
                debugImg.src = canvas.toDataURL();
                debugImg.style.position = 'fixed';
                debugImg.style.top = '10px';
                debugImg.style.right = '10px';
                debugImg.style.width = '100px';
                debugImg.style.height = '100px';
                debugImg.style.border = '1px solid red';
                debugImg.style.zIndex = '9999';
                document.body.appendChild(debugImg);
            }

            return texture;
        }

        // åˆ›å»ºé›ªèŠ±ä¸“ç”¨çº¹ç†
        function createSnowTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºé›ªèŠ±æ¸å˜æ•ˆæœ
            const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0, '#FFFFFF'); // ç™½è‰²ä¸­å¿ƒ
            gradient.addColorStop(0.2, '#FFFFFFEE');
            gradient.addColorStop(0.4, '#FFFFFFCC');
            gradient.addColorStop(0.6, '#FFFFFF88');
            gradient.addColorStop(0.8, '#FFFFFF44');
            gradient.addColorStop(0.95, '#FFFFFF11');
            gradient.addColorStop(1, '#FFFFFF00');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            // æ·»åŠ æ›´æŸ”å’Œçš„å†…éƒ¨é«˜å…‰
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#FFFFFF';
            const padding = size * 0.35;
            ctx.fillRect(padding, padding, size - padding * 2, size - padding * 2);

            // æ·»åŠ ä¸­å¿ƒäº®ç‚¹
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#FFFFFF';
            const centerPadding = size * 0.45;
            ctx.fillRect(centerPadding, centerPadding, size - centerPadding * 2, size - centerPadding * 2);

            ctx.globalAlpha = 1.0;

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // åˆ›å»ºé›ªèŠ±èƒŒæ™¯ï¼ˆç™½è‰²é›ªèŠ±ç²’å­ï¼‰
        const starsGeometry = new THREE.BufferGeometry();
        const starsTexture = createSnowTexture(); // ä½¿ç”¨ä¸“ç”¨çš„é›ªèŠ±çº¹ç†
        const starsVertices = [];
        const starsColors = [];
        const starsSizes = [];

        for (let i = 0; i < 2500; i++) {
            // ä½¿ç”¨çƒå½¢åˆ†å¸ƒè€Œä¸æ˜¯ç«‹æ–¹ä½“åˆ†å¸ƒ
            const radius = Math.random() * 15 + 5; // 5-20çš„åŠå¾„èŒƒå›´
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            starsVertices.push(x, y, z);

            // æ·»åŠ é¢œè‰²å˜åŒ–ï¼ˆç™½è‰²é›ªèŠ±ï¼‰
            const colorIntensity = 0.7 + Math.random() * 0.3; // ç™½è‰²é›ªèŠ±
            starsColors.push(colorIntensity, colorIntensity, colorIntensity); // çº¯ç™½è‰²

            // æ·»åŠ å¤§å°å˜åŒ–ï¼ˆé›ªèŠ±å¤§å°ï¼‰
            starsSizes.push(0.08 + Math.random() * 0.08); // å¢å¤§é›ªèŠ±å¤§å°å˜åŒ–èŒƒå›´
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starsColors, 3));
        starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starsSizes, 1));

        const starsMaterial = new THREE.PointsMaterial({
            map: starsTexture,
            vertexColors: true,
            size: 0.15, // å¢å¤§é›ªèŠ±å°ºå¯¸
            transparent: true,
            opacity: 0.6, // é›ªèŠ±é€æ˜åº¦
            blending: THREE.AdditiveBlending,
            depthWrite: true, // å¯ç”¨æ·±åº¦å†™å…¥ï¼Œä½¿é›ªèŠ±å¯ä»¥æ˜¾ç¤ºåœ¨ç‰©ä½“å‰é¢
            depthTest: true, // å¯ç”¨æ·±åº¦æµ‹è¯•
            sizeAttenuation: true
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        stars.renderOrder = -1; // ç¡®ä¿æ˜Ÿæ˜Ÿåœ¨èƒŒæ™¯æ¸²æŸ“
        scene.add(stars);

        // åˆ›å»ºå‰æ™¯é›ªèŠ±ç³»ç»Ÿï¼ˆå¯ä»¥åœ¨åœ£è¯æ ‘å‰é¢é£˜è½çš„é›ªèŠ±ï¼‰
        const foregroundSnowGeometry = new THREE.BufferGeometry();
        const foregroundSnowVertices = [];
        const foregroundSnowColors = [];
        const foregroundSnowSizes = [];

        for (let i = 0; i < 800; i++) {
            // ä½¿ç”¨æ›´å¤§çš„èŒƒå›´ï¼Œä½†ä¸»è¦é›†ä¸­åœ¨ç›¸æœºå‰æ–¹
            const radius = Math.random() * 8 + 2; // 2-10çš„åŠå¾„èŒƒå›´
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.6 + Math.PI * 0.2; // é™åˆ¶åœ¨ç›¸æœºå‰æ–¹

            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            foregroundSnowVertices.push(x, y, z);

            // æ·»åŠ é¢œè‰²å˜åŒ–ï¼ˆç™½è‰²é›ªèŠ±ï¼‰
            const colorIntensity = 0.8 + Math.random() * 0.2; // æ›´äº®çš„ç™½è‰²é›ªèŠ±
            foregroundSnowColors.push(colorIntensity, colorIntensity, colorIntensity); // çº¯ç™½è‰²

            // æ·»åŠ å¤§å°å˜åŒ–ï¼ˆå‰æ™¯é›ªèŠ±æ›´å¤§ï¼‰
            foregroundSnowSizes.push(0.12 + Math.random() * 0.12); // å‰æ™¯é›ªèŠ±æ›´å¤§
        }

        foregroundSnowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(foregroundSnowVertices, 3));
        foregroundSnowGeometry.setAttribute('color', new THREE.Float32BufferAttribute(foregroundSnowColors, 3));
        foregroundSnowGeometry.setAttribute('size', new THREE.Float32BufferAttribute(foregroundSnowSizes, 1));

        const foregroundSnowMaterial = new THREE.PointsMaterial({
            map: starsTexture,
            vertexColors: true,
            size: 0.2, // å‰æ™¯é›ªèŠ±æ›´å¤§
            transparent: true,
            opacity: 0.7, // å‰æ™¯é›ªèŠ±æ›´æ˜æ˜¾
            blending: THREE.AdditiveBlending,
            depthWrite: false, // ä¸å†™å…¥æ·±åº¦ï¼Œç¡®ä¿æ€»æ˜¯åœ¨å‰é¢
            depthTest: true, // å…è®¸æ·±åº¦æµ‹è¯•ï¼Œé˜²æ­¢é˜»æŒ¡ç‚¹å‡»äº‹ä»¶
            sizeAttenuation: true
        });

        const foregroundSnow = new THREE.Points(foregroundSnowGeometry, foregroundSnowMaterial);
        foregroundSnow.renderOrder = 0; // é™ä½æ¸²æŸ“é¡ºåºï¼Œé˜²æ­¢é˜»æŒ¡ç‚¹å‡»äº‹ä»¶
        scene.add(foregroundSnow);

        // åˆ›å»ºç²’å­ç»„
        const particleGroup = new THREE.Group();
        particleGroup.renderOrder = 1; // ç¡®ä¿æ ‘åœ¨åœ°æ¯¯å‰é¢
        scene.add(particleGroup);

        // åˆ›å»ºç²’å­çº¹ç†
        const goldTexture = createSquareTexture('#FFD700');
        const redTexture = createCircleTexture('#FF6B6B');
        const greenTexture = createSquareTexture('#00FF00');

        // ç²’å­æè´¨
        const goldMaterial = new THREE.PointsMaterial({
            map: goldTexture,
            color: 0xFFD700,
            size: 0.09,
            transparent: true,
            opacity: 0.7, // é™ä½ä¸é€æ˜åº¦
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const redMaterial = new THREE.PointsMaterial({
            map: redTexture,
            color: 0xFF6B6B,
            size: 0.09,
            transparent: true,
            opacity: 0.5, // é™ä½ä¸é€æ˜åº¦
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const greenMaterial = new THREE.PointsMaterial({
            map: greenTexture,
            color: 0x00FF00,
            size: 0.1,
            transparent: true,
            opacity: 0.4, // é™ä½ä¸é€æ˜åº¦
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        // åˆ›å»ºåœ£è¯æ ‘å½¢çŠ¶çš„ç²’å­ - ç´§å‡‘çš„æ ‘å½¢ç»“æ„
        function createTreeParticles() {
            const treeHeight = 3.2;
            const baseWidth = 1.6;
            const topWidth = 0.05;
            const layers = 40;
            const particles = [];
            const giftPositions = [];

            // ç”Ÿæˆç²’å­ - å½¢æˆç´§å‡‘æ¸…æ™°çš„æ ‘å½¢è½®å»“
            for (let layer = 0; layer < layers; layer++) {
                const layerProgress = layer / layers;
                const layerY = -treeHeight / 2 + layerProgress * treeHeight;

                // è®¡ç®—è¯¥å±‚çš„å®½åº¦ï¼ˆä»åº•éƒ¨åˆ°é¡¶éƒ¨é€æ¸å˜çª„ï¼Œæ›´ç´§å‡‘ï¼‰
                const layerWidth = baseWidth * (1 - layerProgress * 0.9);

                // æ ¹æ®å±‚æ•°è°ƒæ•´ç²’å­å¯†åº¦ï¼ˆä¸­é—´å±‚æ›´å¯†é›†ï¼Œè®©æ ‘æ›´ç´§å‡‘ï¼‰
                const densityFactor = 1 - Math.abs(layerProgress - 0.5) * 0.5;
                const particlesInLayer = Math.floor(120 * densityFactor * (1 - layerProgress * 0.2));

                for (let i = 0; i < particlesInLayer; i++) {
                    // ä½¿ç”¨æ›´å‡åŒ€çš„è§’åº¦åˆ†å¸ƒ
                    const angle = (i / particlesInLayer) * Math.PI * 2;

                    // ä½¿ç”¨å¾„å‘åˆ†å¸ƒï¼Œä¸­å¿ƒå¯†é›†ï¼Œè¾¹ç¼˜ç¨€ç–ï¼ˆæ›´é›†ä¸­åœ¨ä¸­å¿ƒï¼‰
                    const radialRandom = Math.random();
                    const radiusFactor = Math.pow(radialRandom, 0.7);
                    const radius = radiusFactor * layerWidth * 0.85;

                    // æ·»åŠ è½»å¾®çš„éšæœºåç§»ï¼Œä½†ä¿æŒæ ‘å½¢
                    const noise = (Math.random() - 0.5) * 0.08;
                    const x = Math.cos(angle) * radius + noise;
                    const z = Math.sin(angle) * radius + noise;

                    // Yè½´ä½ç½®ï¼šåœ¨å±‚å†…ç¨å¾®éšæœºåˆ†å¸ƒ
                    const y = layerY + (Math.random() - 0.5) * (treeHeight / layers * 0.7);

                    // ç¡®ä¿ç²’å­åœ¨æ ‘å½¢èŒƒå›´å†…ï¼ˆæ›´ä¸¥æ ¼çš„è¾¹ç•Œï¼‰
                    const distanceFromCenter = Math.sqrt(x * x + z * z);
                    const maxRadius = layerWidth * 0.9;
                    if (distanceFromCenter <= maxRadius) {
                        particles.push(new THREE.Vector3(x, y, z));
                    }
                }
            }

            // å¢å¼ºæ ‘çš„è½®å»“ - åœ¨è¾¹ç¼˜æ·»åŠ å°‘é‡ç²’å­ï¼Œå½¢æˆæ¸…æ™°çš„æ ‘å½¢è¾¹ç•Œï¼ˆç´§å‡‘ï¼‰
            const edgeParticles = [];
            for (let layer = 0; layer < layers; layer++) {
                const layerProgress = layer / layers;
                const layerY = -treeHeight / 2 + layerProgress * treeHeight;
                const layerWidth = baseWidth * (1 - layerProgress * 0.9);

                // åœ¨è¾¹ç¼˜æ·»åŠ å°‘é‡è½®å»“ç²’å­ï¼Œè®©æ ‘å½¢æ›´æ¸…æ™°ä½†ä¿æŒç´§å‡‘
                const edgeParticleCount = Math.floor(18 * (1 - layerProgress * 0.4));
                for (let i = 0; i < edgeParticleCount; i++) {
                    const angle = (i / edgeParticleCount) * Math.PI * 2;
                    const radius = layerWidth * 0.88;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = layerY + (Math.random() - 0.5) * 0.06;
                    edgeParticles.push(new THREE.Vector3(x, y, z));
                }
            }
            particles.push(...edgeParticles);

            // åˆ›å»ºé‡‘è‰²ç²’å­ï¼ˆä¸»è¦æ„æˆæ ‘ä½“ï¼‰- æ›´ç´§å‡‘çš„åˆ†å¸ƒ
            const goldGeometry = new THREE.BufferGeometry();
            const goldPositions = [];
            particles.forEach((pos, i) => {
                const distanceFromCenter = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                const maxRadius = baseWidth * (1 - (pos.y + treeHeight / 2) / treeHeight * 0.9);
                const normalizedDistance = distanceFromCenter / maxRadius;

                // ä¸­å¿ƒåŒºåŸŸæ›´å¯†é›†ï¼Œè®©æ ‘æ›´ç´§å‡‘
                let goldChance;
                if (normalizedDistance < 0.4) {
                    goldChance = 0.95;
                } else if (normalizedDistance < 0.7) {
                    goldChance = 0.85;
                } else {
                    goldChance = 0.75;
                }

                if (Math.random() > (1 - goldChance)) {
                    goldPositions.push(pos.x, pos.y, pos.z);
                }
            });
            goldGeometry.setAttribute('position', new THREE.Float32BufferAttribute(goldPositions, 3));
            const goldParticles = new THREE.Points(goldGeometry, goldMaterial);
            particleGroup.add(goldParticles);

            // åˆ›å»ºçº¢è‰²ç²’å­ï¼ˆç¤¼ç‰©ï¼‰- æ›´å°‘ä¸”åˆ†æ•£åœ¨è¡¨å±‚
            const redGeometry = new THREE.BufferGeometry();
            const redPositions = [];
            let giftIndex = 0;
            particles.forEach((pos, i) => {
                // çº¢è‰²ç²’å­æ›´å‡åŒ€åˆ†å¸ƒï¼Œå‡å°‘çªå…€æ„Ÿ
                const layerProgress = (pos.y + treeHeight / 2) / treeHeight;
                const distanceFromCenter = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                const treeCurve = Math.sin(layerProgress * Math.PI) * 0.3 + 0.7;
                const maxRadius = baseWidth * treeCurve * (1 - layerProgress * 0.7);
                const normalizedDistance = distanceFromCenter / maxRadius;

                // ä½¿ç”¨æ›´æŸ”å’Œçš„åˆ†å¸ƒæ›²çº¿ï¼Œçº¢è‰²ç²’å­æ›´å°‘ä¸”æ›´å‡åŒ€ï¼Œä¸»è¦åˆ†å¸ƒåœ¨è¡¨å±‚
                const distributionCurve = Math.cos(normalizedDistance * Math.PI * 0.7);
                const redProbability = 0.98 - distributionCurve * 0.02; // å¤§å¹…å‡å°‘çº¢è‰²ç²’å­æ•°é‡

                // ä¼˜å…ˆé€‰æ‹©è¡¨å±‚çš„ç²’å­ï¼ˆè·ç¦»ä¸­å¿ƒè¾ƒè¿œçš„ç²’å­ï¼‰
                const surfacePreference = normalizedDistance > 0.6 ? 0.5 : 1.0;

                if (Math.random() > redProbability * surfacePreference) {
                    redPositions.push(pos.x, pos.y, pos.z);
                    // æ ‡è®°ä¸ºå¯ç‚¹å‡»çš„ç¤¼ç‰©ï¼Œæ›´å‡åŒ€åˆ†å¸ƒä¸”ä¸»è¦åœ¨è¡¨å±‚
                    if (Math.random() > 0.92 && normalizedDistance > 0.5) { // è¿›ä¸€æ­¥å‡å°‘å¯ç‚¹å‡»ç¤¼ç‰©çš„æ•°é‡ï¼Œä¸”ä¸»è¦åœ¨è¡¨å±‚
                        giftPositions.push({ x: pos.x, y: pos.y, z: pos.z, index: giftIndex++ });
                    }
                }
            });
            redGeometry.setAttribute('position', new THREE.Float32BufferAttribute(redPositions, 3));
            const redParticles = new THREE.Points(redGeometry, redMaterial);
            particleGroup.add(redParticles);

            // åˆ›å»ºç»¿è‰²ç²’å­ï¼ˆå¢åŠ æ•°é‡ï¼Œä½œä¸ºè£…é¥°ç‚¹ç¼€ï¼‰
            const greenGeometry = new THREE.BufferGeometry();
            const greenPositions = [];
            particles.forEach((pos, i) => {
                // å¢åŠ ç»¿è‰²ç²’å­çš„æ•°é‡ï¼Œä»1%å¢åŠ åˆ°15%
                if (Math.random() > 0.85) {
                    greenPositions.push(pos.x, pos.y, pos.z);
                }
            });
            if (greenPositions.length > 0) {
                greenGeometry.setAttribute('position', new THREE.Float32BufferAttribute(greenPositions, 3));

                // åˆ›å»ºæ›´ç²¾ç¾çš„ç»¿è‰²ç²’å­æè´¨
                const greenMaterial = new THREE.PointsMaterial({
                    map: greenTexture,
                    color: 0x00FF00,
                    size: 0.12,
                    transparent: true,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    sizeAttenuation: true
                });

                const greenParticles = new THREE.Points(greenGeometry, greenMaterial);
                particleGroup.add(greenParticles);
            }

            return giftPositions;
        }

        // åˆ›å»ºå¯ç‚¹å‡»çš„ç¤¼ç‰©ï¼ˆç”¨æ›´å¤§çš„å‘å…‰çƒä½“è¡¨ç¤ºï¼‰
        function createGifts(giftPositions) {
            const giftMeshes = [];
            const giftTexture = createCircleTexture('#FF6B6B');
            giftPositions.forEach((gift, index) => {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    map: giftTexture,
                    color: 0xFF6B6B,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0xFF6B6B,
                    emissiveIntensity: 0.2, // é™ä½è‡ªå‘å…‰å¼ºåº¦ï¼Œå‡å°‘åˆºçœ¼æ•ˆæœ
                    blending: THREE.AdditiveBlending
                });
                const giftMesh = new THREE.Mesh(geometry, material);
                giftMesh.position.set(gift.x, gift.y, gift.z);
                giftMesh.renderOrder = 1; // ç¡®ä¿ç¤¼ç‰©åœ¨åœ°æ¯¯å‰é¢
                giftMesh.userData = { isGift: true, index: index };
                particleGroup.add(giftMesh);
                giftMeshes.push(giftMesh);
            });
            return giftMeshes;
        }

        const giftPositions = createTreeParticles();
        const giftMeshes = createGifts(giftPositions);

        // åˆ›å»ºåœ£è¯æ ‘ä¸Šçš„å°ç¤¼ç›’
        function createTreeGifts() {
            const treeGifts = [];
            const colors = ['#FF4444', '#44FF44', '#4444FF', '#FFFF44', '#FF44FF', '#44FFFF'];
            const giftCount = 30; // æ ‘ä¸Š30ä¸ªå°ç¤¼ç›’

            for (let i = 0; i < giftCount; i++) {
                const color = colors[i % colors.length];
                const giftSize = 0.12 + Math.random() * 0.05; // å°ç¤¼ç›’å°ºå¯¸ 0.12-0.17

                // åˆ›å»ºå°ç¤¼ç›’å‡ ä½•ä½“
                const geometry = new THREE.BoxGeometry(giftSize, giftSize, giftSize);

                // åˆ›å»ºçº¹ç†
                const texture = createGiftBoxTexture(color);

                // ä½¿ç”¨MeshStandardMaterialå¢å¼ºå…‰ç…§æ•ˆæœ
                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    depthTest: true,
                    depthWrite: true,
                    roughness: 0.3,
                    metalness: 0.1,
                    emissive: new THREE.Color(0x000000),
                    emissiveIntensity: 0.1,
                    envMapIntensity: 0.1
                });

                const giftBox = new THREE.Mesh(geometry, material);

                // è®¡ç®—åœ¨åœ£è¯æ ‘è¡¨é¢çš„ä½ç½®
                const treeHeight = 3.2;
                const baseWidth = 1.6;
                const heightProgress = 0.2 + Math.random() * 0.6; // åœ¨æ ‘çš„ä¸­ä¸Šéƒ¨
                const y = -treeHeight / 2 + heightProgress * treeHeight;
                const layerWidth = baseWidth * (1 - heightProgress * 0.9);
                const radius = layerWidth * (0.6 + Math.random() * 0.3); // åœ¨æ ‘è¡¨é¢
                const angle = Math.random() * Math.PI * 2;

                giftBox.position.x = Math.cos(angle) * radius;
                giftBox.position.y = y;
                giftBox.position.z = Math.sin(angle) * radius;

                // éšæœºæ—‹è½¬
                giftBox.rotation.x = Math.random() * Math.PI * 2;
                giftBox.rotation.y = Math.random() * Math.PI * 2;
                giftBox.rotation.z = Math.random() * Math.PI * 2;

                // å¯ç”¨é˜´å½±
                giftBox.castShadow = true;
                giftBox.receiveShadow = true;

                particleGroup.add(giftBox);
                treeGifts.push(giftBox);
            }

            return treeGifts;
        }

        const treeGifts = createTreeGifts();

        // ç»˜åˆ¶åœ£è¯è€äºº
        function drawSantaClaus(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // èº«ä½“ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // è„¸éƒ¨ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, -size * 0.3, size * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // å¸½å­ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.moveTo(-size * 0.4, -size * 0.5);
            ctx.lineTo(size * 0.4, -size * 0.5);
            ctx.lineTo(0, -size * 1.2);
            ctx.closePath();
            ctx.fill();

            // å¸½å­ä¸Šçš„æ¯›çƒï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, -size * 1.2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // èƒ¡é¡»ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, size * 0.1, size * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // çœ¼ç›ï¼ˆé»‘è‰²ï¼‰
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-size * 0.15, -size * 0.35, size * 0.05, 0, Math.PI * 2);
            ctx.arc(size * 0.15, -size * 0.35, size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ç»˜åˆ¶éº‹é¹¿
        function drawReindeer(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // èº«ä½“ï¼ˆæ£•è‰²ï¼‰
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(0, 0, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // å¤´éƒ¨
            ctx.beginPath();
            ctx.arc(size * 0.5, -size * 0.2, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // è…¿
            ctx.fillRect(-size * 0.5, size * 0.2, size * 0.15, size * 0.4);
            ctx.fillRect(-size * 0.1, size * 0.2, size * 0.15, size * 0.4);
            ctx.fillRect(size * 0.1, size * 0.2, size * 0.15, size * 0.4);
            ctx.fillRect(size * 0.5, size * 0.2, size * 0.15, size * 0.4);

            // é¹¿è§’ï¼ˆæ£•è‰²ï¼‰
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            // å·¦è§’
            ctx.moveTo(size * 0.4, -size * 0.3);
            ctx.lineTo(size * 0.3, -size * 0.6);
            ctx.lineTo(size * 0.2, -size * 0.5);
            ctx.moveTo(size * 0.3, -size * 0.6);
            ctx.lineTo(size * 0.25, -size * 0.8);
            // å³è§’
            ctx.moveTo(size * 0.6, -size * 0.3);
            ctx.lineTo(size * 0.7, -size * 0.6);
            ctx.lineTo(size * 0.8, -size * 0.5);
            ctx.moveTo(size * 0.7, -size * 0.6);
            ctx.lineTo(size * 0.75, -size * 0.8);
            ctx.stroke();

            // é¼»å­ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.arc(size * 0.6, -size * 0.2, size * 0.08, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // åˆ›å»º3Dåœ°æ¯¯
        function createCarpet() {
            // åˆ›å»ºåœ°æ¯¯å‡ ä½•ä½“ï¼ˆå¹³é¢ï¼‰
            const geometry = new THREE.PlaneGeometry(6, 6);

            // åˆ›å»ºåœ°æ¯¯æè´¨
            const textureCanvas = document.createElement('canvas');
            const ctx = textureCanvas.getContext('2d');
            textureCanvas.width = 512;
            textureCanvas.height = 512;

            // 1. ç»˜åˆ¶æ›´å…·é«˜çº§æ„Ÿçš„é…’çº¢/å‹ƒè‰®ç¬¬çº¢æ¸å˜èƒŒæ™¯
            const gradient = ctx.createRadialGradient(256, 256, 50, 256, 256, 400);
            gradient.addColorStop(0, '#5a0a16'); // æ·±é…’çº¢ (Wine Red)
            gradient.addColorStop(1, '#2d050b'); // ææ·±è¤çº¢ (Deep Burgundy)
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // 1.5 å¢åŠ ä¸ç»’è´¨æ„Ÿæ•ˆæœ (Subtle Velvet Texture)
            ctx.globalAlpha = 0.15;
            for (let i = 0; i < 20; i++) {
                const innerGlow = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
                innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                innerGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = innerGlow;
                ctx.fillRect(0, 0, 512, 512);
            }
            ctx.globalAlpha = 1.0;

            // 2. å¢åŠ åœ°æ¯¯ç»‡ç‰©çº¹ç†æ„Ÿ (å¾®å°å™ªç‚¹)
            for (let i = 0; i < 5000; i++) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.03})`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 1);
            }

            // 3. æ·»åŠ ç°è‰²é«˜çº§æ„Ÿè¾¹æ¡†
            ctx.strokeStyle = '#A0A0A0'; // ä¸­ç°è‰²
            ctx.lineWidth = 15;
            ctx.strokeRect(10, 10, 492, 492);
            ctx.lineWidth = 5;
            ctx.strokeRect(30, 30, 452, 452);

            // 4. ç»˜åˆ¶å››ä¸ªè§’è½çš„å†¬é’å¶è£…é¥°
            const corners = [[45, 45], [467, 45], [45, 467], [467, 467]];
            corners.forEach(([cx, cy]) => {
                ctx.fillStyle = '#228B22'; // æ£®æ—ç»¿
                ctx.beginPath();
                ctx.ellipse(cx, cy, 15, 8, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx, cy, 15, 8, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF0000'; // çº¢è‰²æµ†æœ
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // 5. ç»˜åˆ¶è§’è‰²å‰ªå½± (å¥³å­©ã€ç”·å­©ã€ä¸¤åªå°çŒ«)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';

            // --- ç»˜åˆ¶å¥³å­© (å·¦ä¾§) ---
            const gx = 210, gy = 220;
            ctx.beginPath(); ctx.arc(gx, gy, 22, 0, Math.PI * 2); ctx.fill(); // å¤´
            ctx.beginPath(); ctx.arc(gx - 20, gy - 5, 8, 0, Math.PI * 2); ctx.arc(gx + 20, gy - 5, 8, 0, Math.PI * 2); ctx.fill(); // è¾«å­
            ctx.beginPath(); ctx.moveTo(gx, gy + 22); ctx.lineTo(gx - 35, gy + 110); ctx.lineTo(gx + 35, gy + 110); ctx.closePath(); ctx.fill(); // è£™å­

            // --- ç»˜åˆ¶ç”·å­© (å³ä¾§) ---
            const bx = 300, by = 220;
            ctx.beginPath(); ctx.arc(bx, by, 22, 0, Math.PI * 2); ctx.fill(); // å¤´
            ctx.fillRect(bx - 22, by - 25, 44, 15); // å¤´å‘
            ctx.beginPath(); ctx.moveTo(bx - 25, by + 22); ctx.lineTo(bx + 25, by + 22); ctx.lineTo(bx + 28, by + 110); ctx.lineTo(bx - 28, by + 110); ctx.closePath(); ctx.fill(); // èº«ä½“

            // --- ç»˜åˆ¶çˆ±å¿ƒ (åœ¨ä¸¤äººä¹‹é—´) ---
            ctx.fillStyle = '#FFB6C1';
            function drawHeart(x, y, size) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.bezierCurveTo(x, y - size, x - size, y - size, x - size, y);
                ctx.bezierCurveTo(x - size, y + size, x, y + size, x, y + size * 2);
                ctx.bezierCurveTo(x, y + size, x + size, y + size, x + size, y);
                ctx.bezierCurveTo(x + size, y - size, x, y - size, x, y);
                ctx.fill();
            }
            drawHeart(255, 180, 12);
            drawHeart(235, 150, 8);
            drawHeart(275, 155, 8);

            // --- ç»˜åˆ¶å°çŒ« 1 & 2 ---
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            const cats = [[140, 310], [370, 310]];
            cats.forEach(([cx, cy]) => {
                ctx.beginPath(); ctx.ellipse(cx, cy, 15, 22, 0, 0, Math.PI * 2); ctx.fill(); // èº«ä½“
                ctx.beginPath(); ctx.arc(cx, cy - 25, 12, 0, Math.PI * 2); ctx.fill(); // å¤´
                ctx.beginPath(); ctx.moveTo(cx - 10, cy - 32); ctx.lineTo(cx - 12, cy - 45); ctx.lineTo(cx - 2, cy - 35); ctx.fill(); // è€³
                ctx.beginPath(); ctx.moveTo(cx + 10, cy - 32); ctx.lineTo(cx + 12, cy - 45); ctx.lineTo(cx + 2, cy - 35); ctx.fill(); // è€³
            });

            // --- ç»˜åˆ¶çŒ«çˆªå° (Paw Prints) ---
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            function drawPaw(x, y) {
                ctx.beginPath(); ctx.ellipse(x, y, 5, 4, 0, 0, Math.PI * 2); ctx.fill(); // æŒå«
                ctx.beginPath(); ctx.arc(x - 5, y - 6, 2, 0, Math.PI * 2); ctx.fill(); // è¶¾å«
                ctx.beginPath(); ctx.arc(x, y - 8, 2, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + 5, y - 6, 2, 0, Math.PI * 2); ctx.fill();
            }
            drawPaw(110, 350); drawPaw(125, 370);
            drawPaw(400, 350); drawPaw(385, 370);

            // 6. æ·»åŠ è£…é¥°å…ƒç´ ï¼šé›ªèŠ±ã€æ˜Ÿæ˜Ÿå’Œå†·æ‰è½å¶
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = 1.5 + Math.random() * 2.5;
                drawStar(ctx, x, y, 5, size, size / 2);
            }

            // --- ç»˜åˆ¶å†·æ‰è½å¶ (Fir Needles) ---
            function drawFirNeedle(x, y, angle, length, opacity = 0.7, color = 'rgba(20, 60, 20, ') {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                // ä½¿ç”¨ä¼ å…¥çš„é¢œè‰²åŸºç¡€
                ctx.strokeStyle = color + opacity + ')';
                ctx.lineWidth = 1.8;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(length, 0);
                ctx.stroke();
                // å¢åŠ åˆ†å‰ï¼Œæ¨¡æ‹Ÿå†·æ‰å¶ç‰¹å¾
                ctx.lineWidth = 1.0;
                for (let j = 0; j < 4; j++) {
                    const px = (j + 1) * (length / 5);
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px + 3.5, 3.5);
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px + 3.5, -3.5);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // 1. å…¨å±€éšæœºæ•£è½çš„è½å¶ (é¿å¼€è§’è‰²åŒºåŸŸ)
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 460 + 26;
                const y = Math.random() * 460 + 26;

                // é¿å¼€å¥³å­©ç”·å­©ä¸­å¿ƒåŒºåŸŸ (170-340, 180-340) å’Œ å°çŒ«åŒºåŸŸ
                if ((x > 160 && x < 350 && y > 150 && y < 350) ||
                    (x > 110 && x < 170 && y > 270 && y < 350) ||
                    (x > 340 && x < 400 && y > 270 && y < 350)) continue;

                const angle = Math.random() * Math.PI * 2;
                const length = 10 + Math.random() * 15;
                drawFirNeedle(x, y, angle, length, 0.6);
            }

            // 2. åœ£è¯æ ‘ä¸‹å¯†é›†å †æ”¾çš„è½å¶ (ä½ç½®ä¸‹ç§»ï¼Œä¸åœ°é¢ç¤¼ç›’å‘¼åº”ï¼Œé¿å¼€è§’è‰²)
            const treeRootX = 256;
            const treeRootY = 360;

            // ç¬¬ä¸€å±‚ï¼šåº•å±‚æ·±è‰²è½å¶
            for (let i = 0; i < 600; i++) {
                const radius = Math.sqrt(Math.random()) * 110;
                const angle_pos = Math.random() * Math.PI * 2;
                const x = treeRootX + Math.cos(angle_pos) * radius;
                const y = treeRootY + Math.sin(angle_pos) * radius;

                if (x > 160 && x < 350 && y > 180 && y < 340) continue;

                const angle_needle = Math.random() * Math.PI * 2;
                const length = 12 + Math.random() * 12;
                drawFirNeedle(x, y, angle_needle, length, 0.4, 'rgba(10, 30, 10, ');
            }

            // ç¬¬äºŒå±‚ï¼šä¸­é—´å±‚æ ‡å‡†è½å¶
            for (let i = 0; i < 800; i++) {
                const radius = Math.sqrt(Math.random()) * 95;
                const angle_pos = Math.random() * Math.PI * 2;
                const x = treeRootX + Math.cos(angle_pos) * radius;
                const y = treeRootY + Math.sin(angle_pos) * radius;

                if (x > 160 && x < 350 && y > 180 && y < 340) continue;

                const angle_needle = Math.random() * Math.PI * 2;
                const length = 15 + Math.random() * 15;
                const opacity = 0.5 + (1 - radius / 95) * 0.4;
                drawFirNeedle(x, y, angle_needle, length, opacity, 'rgba(20, 60, 20, ');
            }

            // ç¬¬ä¸‰å±‚ï¼šé¡¶å±‚äº®è‰²è½å¶
            for (let i = 0; i < 400; i++) {
                const radius = Math.sqrt(Math.random()) * 80;
                const angle_pos = Math.random() * Math.PI * 2;
                const x = treeRootX + Math.cos(angle_pos) * radius;
                const y = treeRootY + Math.sin(angle_pos) * radius;

                if (x > 160 && x < 350 && y > 180 && y < 340) continue;

                const angle_needle = Math.random() * Math.PI * 2;
                const length = 10 + Math.random() * 10;
                const opacity = 0.3 + (1 - radius / 80) * 0.3;
                drawFirNeedle(x, y, angle_needle, length, opacity, 'rgba(40, 90, 40, ');
            }

            // 3. åœ¨æ¯ä¸ªåœ°ä¸Šç¤¼ç›’åº•éƒ¨é¢å¤–å¢åŠ ä¸€äº›æ•£è½çš„è½å¶
            const giftCanvasPositions = [
                [179, 409], [213, 341], [298, 350], [333, 401]
            ];
            giftCanvasPositions.forEach(([gx, gy]) => {
                for (let i = 0; i < 100; i++) {
                    const radius = Math.sqrt(Math.random()) * 40;
                    const angle_pos = Math.random() * Math.PI * 2;
                    const x = gx + Math.cos(angle_pos) * radius;
                    const y = gy + Math.sin(angle_pos) * radius;
                    const angle_needle = Math.random() * Math.PI * 2;
                    const length = 8 + Math.random() * 10;
                    drawFirNeedle(x, y, angle_needle, length, 0.5, 'rgba(20, 60, 20, ');
                }
            });

            // 7. æ·»åŠ æ–‡å­—è£…é¥°
            ctx.fillStyle = '#E0E0E0'; // æµ…ç°è‰²ï¼Œä¸è¾¹æ¡†å‘¼åº”
            ctx.font = 'bold 28px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Merry Christmas & Always Together', 256, 445);

            const texture = new THREE.CanvasTexture(textureCanvas);
            texture.needsUpdate = true;

            // åˆ›å»ºæè´¨
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95
            });

            // åˆ›å»ºåœ°æ¯¯ç½‘æ ¼
            const carpet = new THREE.Mesh(geometry, material);

            // å°†åœ°æ¯¯æ”¾ç½®åœ¨æ ‘çš„ä¸‹æ–¹ï¼ˆy = -2ï¼Œç•¥ä½äºæ ‘çš„åº•éƒ¨ï¼‰
            carpet.position.y = -2;
            carpet.position.z = -0.5; // å°†åœ°æ¯¯ç¨å¾®å‘åç§»åŠ¨ï¼Œä½¿å…¶ä½äºæ ‘çš„åé¢

            // æ—‹è½¬åœ°æ¯¯ä½¿å…¶æ°´å¹³æ”¾ç½®
            carpet.rotation.x = -Math.PI / 2;

            // å¯ç”¨é˜´å½±æ¥æ”¶ï¼Œä½¿åœ°æ¯¯å¯ä»¥æ¥æ”¶å…¶ä»–ç‰©ä½“çš„é˜´å½±
            carpet.receiveShadow = true;

            // è®¾ç½®æ¸²æŸ“é¡ºåºï¼Œç¡®ä¿åœ°æ¯¯åœ¨æ ‘åé¢
            carpet.renderOrder = -1;

            // è®¾ç½®ç”¨æˆ·æ•°æ®ä»¥ä¾¿è¯†åˆ«
            carpet.userData = { isCarpet: true };

            return carpet;
        }

        // åˆ›å»ºåœ°æ¯¯å¹¶æ·»åŠ åˆ°åœºæ™¯
        const carpet = createCarpet();
        scene.add(carpet);

        // æ·»åŠ å…‰æºä»¥å¢å¼ºé˜´å½±æ•ˆæœ
        // é™ä½ç¯å¢ƒå…‰å¼ºåº¦ï¼Œå‡å°‘åˆºçœ¼æ•ˆæœ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // é™ä½ç¯å¢ƒå…‰å¼ºåº¦
        scene.add(ambientLight);

        // ä¸»æ–¹å‘å…‰ï¼Œæä¾›ä¸»è¦ç…§æ˜å’Œé˜´å½±ï¼ˆé™ä½å¼ºåº¦ï¼‰
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // é™ä½æ–¹å‘å…‰å¼ºåº¦
        directionalLight.position.set(3, 5, 2);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048; // å¢åŠ é˜´å½±è´´å›¾åˆ†è¾¨ç‡
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 20;
        directionalLight.shadow.camera.left = -5;
        directionalLight.shadow.camera.right = 5;
        directionalLight.shadow.camera.top = 5;
        directionalLight.shadow.camera.bottom = -5;
        scene.add(directionalLight);

        // æ·»åŠ è¡¥å……å…‰æºï¼Œå¢å¼ºç«‹ä½“æ„Ÿï¼ˆé™ä½å¼ºåº¦ï¼‰
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.2); // é™ä½è¡¥å……å…‰æºå¼ºåº¦
        fillLight.position.set(-3, 3, -2);
        scene.add(fillLight);

        // æ·»åŠ èƒŒå…‰ï¼Œå¢å¼ºè½®å»“æ•ˆæœï¼ˆé™ä½å¼ºåº¦ï¼‰
        const backLight = new THREE.DirectionalLight(0xffffff, 0.15); // é™ä½èƒŒå…‰å¼ºåº¦
        backLight.position.set(0, 2, -5);
        scene.add(backLight);

        // æ·»åŠ ç‚¹å…‰æºï¼Œå¢å¼ºå±€éƒ¨ç…§æ˜æ•ˆæœï¼ˆé™ä½å¼ºåº¦ï¼‰
        const pointLight = new THREE.PointLight(0xffffff, 0.3, 10); // é™ä½ç‚¹å…‰æºå¼ºåº¦
        pointLight.position.set(0, 1, 0);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // åˆ›å»ºåœ°é¢ç¤¼ç›’æ•°ç»„
        const groundGifts = [];

        // åˆ›å»ºåœ°é¢ç¤¼ç›’
        function createGroundGift(color, x, z, index) {
            // ä½¿ç”¨å¢å¼ºç‰ˆçš„createGiftBoxå‡½æ•°åˆ›å»ºç¤¼ç›’ï¼Œå‡å°ç¤¼ç›’å°ºå¯¸
            const giftBox = createGiftBox(color, index, 0.35, true); // å‡å°ç¤¼ç›’å°ºå¯¸åˆ°0.35

            // è®¾ç½®ç¤¼ç›’ä½ç½®åœ¨åœ°æ¯¯ä¸Š
            giftBox.position.x = x;
            giftBox.position.y = -1.7; // ç•¥é«˜äºåœ°æ¯¯
            giftBox.position.z = z; // ç›´æ¥ä½¿ç”¨ä¼ å…¥çš„zåæ ‡

            // æ·»åŠ éšæœºæ—‹è½¬ï¼Œè¥é€ è‡ªç„¶æ•£è½æ„Ÿ
            giftBox.rotation.x = (Math.random() - 0.5) * 0.3; // è½»å¾®Xè½´å€¾æ–œ
            giftBox.rotation.y = Math.random() * Math.PI * 2; // éšæœºYè½´æ—‹è½¬
            giftBox.rotation.z = (Math.random() - 0.5) * 0.2; // è½»å¾®Zè½´å€¾æ–œ

            // å¯ç”¨é˜´å½±æŠ•å°„å’Œæ¥æ”¶ï¼Œå¢å¼ºç«‹ä½“æ•ˆæœ
            giftBox.castShadow = true;
            giftBox.receiveShadow = true;

            // è®¾ç½®ç”¨æˆ·æ•°æ®æ ‡è¯†ä¸ºåœ°é¢ç¤¼ç›’
            giftBox.userData = {
                isGroundGift: true,
                index: index,
                isOpen: false,
                baseY: -1.7,
                animationPhase: Math.random() * Math.PI * 2,
                rotationSpeed: 0.005 + Math.random() * 0.005
            };

            // æ·»åŠ åˆ°åœºæ™¯å’Œæ•°ç»„ä¸­
            scene.add(giftBox);
            groundGifts.push(giftBox);

            return giftBox;
        }

        // åœ¨å›ºå®šä½ç½®æ”¾ç½®4ä¸ªç¤¼ç›’
        function placeFixedGroundGifts() {
            // è°ƒæ•´é¢œè‰²å’Œä½ç½®é¡ºåºï¼Œä½¿ç¬¬4ä¸ªç¤¼ç›’ï¼ˆç´¢å¼•4ï¼‰æ˜¯ç»¿è‰²ä¸”ä½äºæœ€å³ä¾§
            const colors = ['#FF4444', '#FFFF44', '#4444FF', '#44FF44'];

            // å›ºå®šä½ç½®åæ ‡ (x, z)
            const fixedPositions = [
                { x: -0.9, z: 1.8 }, // 1: å·¦å (çº¢)
                { x: -0.5, z: 1.0 }, // 2: å·¦å‰ (é»„)
                { x: 0.5, z: 1.1 },  // 3: å³å‰ (è“)
                { x: 0.9, z: 1.7 }   // 4: å³å (ç»¿) - å¯¹åº”ç”¨æˆ·ç®­å¤´çš„ç»¿è‰²ç®±å­
            ];

            // åœ¨å›ºå®šä½ç½®æ”¾ç½®ç¤¼ç›’
            for (let i = 0; i < 4; i++) {
                createGroundGift(colors[i], fixedPositions[i].x, fixedPositions[i].z, i + 1);
            }
        }

        // åœ¨å›ºå®šä½ç½®æ”¾ç½®4ä¸ªç¤¼ç›’
        placeFixedGroundGifts();

        // åˆ›å»ºæ›´ç²¾ç¾çš„äº”è§’æ˜Ÿ/é’»çŸ³è£…é¥°
        function createStar() {
            // åˆ›å»ºäº”è§’æ˜Ÿå½¢çŠ¶çš„é’»çŸ³è£…é¥°
            const starGroup = new THREE.Group();
            const starY = 1.6;

            // åˆ›å»ºäº”è§’æ˜Ÿçš„æ ¸å¿ƒå½¢çŠ¶
            const starShape = new THREE.Shape();
            const outerRadius = 0.25; // å¢å¤§äº”è§’æ˜Ÿå°ºå¯¸
            const innerRadius = 0.12;

            for (let i = 0; i < 5; i++) {
                const angle1 = (i * 2 * Math.PI / 5) - Math.PI / 2;
                const angle2 = ((i + 0.5) * 2 * Math.PI / 5) - Math.PI / 2;

                if (i === 0) {
                    starShape.moveTo(Math.cos(angle1) * outerRadius, Math.sin(angle1) * outerRadius);
                } else {
                    starShape.lineTo(Math.cos(angle1) * outerRadius, Math.sin(angle1) * outerRadius);
                }
                starShape.lineTo(Math.cos(angle2) * innerRadius, Math.sin(angle2) * innerRadius);
            }
            starShape.closePath();

            // åˆ›å»ºäº”è§’æ˜Ÿå‡ ä½•ä½“
            const starGeometry = new THREE.ShapeGeometry(starShape);
            const starMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF, // çº¯ç™½è‰²ï¼Œä¸åœ£è¯æ ‘æ›´æ­é…
                transparent: true,
                opacity: 0.95,
                emissive: 0xFFFFCC, // æ·¡é»„è‰²å‘å…‰ï¼Œæ¸©æš–æ„Ÿ
                emissiveIntensity: 0.4, // é™ä½è‡ªå‘å…‰å¼ºåº¦ï¼Œå‡å°‘åˆºçœ¼æ•ˆæœ
                side: THREE.DoubleSide
            });

            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.position.y = starY;
            starMesh.rotation.z = Math.PI;
            starGroup.add(starMesh);

            // åˆ›å»ºé’»çŸ³æ•ˆæœçš„å¤šå±‚äº”è§’æ˜Ÿ
            for (let i = 0; i < 3; i++) {
                const scale = 1 - i * 0.2;
                const opacity = 0.7 - i * 0.2;
                const layerStar = starMesh.clone();
                layerStar.scale.set(scale, scale, scale);
                layerStar.material = starMaterial.clone();
                layerStar.material.opacity = opacity;
                layerStar.position.z = i * 0.02;
                starGroup.add(layerStar);
            }

            // æ·»åŠ å‘å…‰ç²’å­æ•ˆæœ
            const glowGeometry = new THREE.BufferGeometry();
            const glowPositions = [];

            // åœ¨äº”è§’æ˜Ÿå‘¨å›´æ·»åŠ å‘å…‰ç²’å­
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.2;
                const height = starY + (Math.random() - 0.5) * 0.1;
                glowPositions.push(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
            }

            glowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(glowPositions, 3));
            const glowMaterial = new THREE.PointsMaterial({
                map: goldTexture,
                color: 0xFFFFCC, // æ·¡é»„è‰²å‘å…‰ç²’å­ï¼Œä¸åœ£è¯æ ‘æ›´æ­é…
                size: 0.2, // å¢å¤§å‘å…‰ç²’å­å°ºå¯¸
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const glowParticles = new THREE.Points(glowGeometry, glowMaterial);
            starGroup.add(glowParticles);

            // æ·»åŠ æ—‹è½¬åŠ¨ç”»
            starGroup.userData = {
                rotationSpeed: 0.01,
                isStar: true // æ ‡è¯†è¿™æ˜¯æ˜Ÿæ˜Ÿå¯¹è±¡
            };

            particleGroup.add(starGroup);
            return starGroup;
        }

        const treeStar = createStar();

        // åˆ›å»ºæµæ˜Ÿæ•ˆæœ
        let shootingStars = [];

        function createShootingStar() {
            const shootingStar = {
                geometry: new THREE.BufferGeometry(),
                material: new THREE.LineBasicMaterial({
                    color: 0xFFFFFF,
                    opacity: 0,
                    transparent: true
                }),
                positions: [],
                startTime: Date.now(),
                duration: 2000 + Math.random() * 1000,
                active: false
            };

            // åˆå§‹åŒ–æµæ˜Ÿè½¨è¿¹ç‚¹
            for (let i = 0; i < 20; i++) {
                shootingStar.positions.push(0, 0, 0);
            }

            shootingStar.geometry.setAttribute('position', new THREE.Float32BufferAttribute(shootingStar.positions, 3));
            shootingStar.line = new THREE.Line(shootingStar.geometry, shootingStar.material);
            shootingStar.line.visible = false;

            scene.add(shootingStar.line);
            shootingStars.push(shootingStar);

            return shootingStar;
        }

        // åˆ›å»º5é¢—æµæ˜Ÿ
        for (let i = 0; i < 5; i++) {
            createShootingStar();
        }

        function updateShootingStars() {
            const time = Date.now();

            shootingStars.forEach(star => {
                if (!star.active && Math.random() < 0.002) { // éšæœºæ¿€æ´»æµæ˜Ÿ
                    star.active = true;
                    star.startTime = time;
                    star.line.visible = true;

                    // éšæœºèµ·å§‹ä½ç½®å’Œæ–¹å‘
                    const startX = (Math.random() - 0.5) * 30;
                    const startY = 10 + Math.random() * 10;
                    const startZ = (Math.random() - 0.5) * 30;

                    const endX = startX + (Math.random() - 0.5) * 20;
                    const endY = -5;
                    const endZ = startZ + (Math.random() - 0.5) * 20;

                    // æ›´æ–°æµæ˜Ÿè½¨è¿¹
                    for (let i = 0; i < 20; i++) {
                        const t = i / 19;
                        star.positions[i * 3] = startX + (endX - startX) * t;
                        star.positions[i * 3 + 1] = startY + (endY - startY) * t;
                        star.positions[i * 3 + 2] = startZ + (endZ - startZ) * t;
                    }

                    star.geometry.attributes.position.needsUpdate = true;
                }

                if (star.active) {
                    const elapsed = time - star.startTime;
                    const progress = elapsed / star.duration;

                    if (progress >= 1) {
                        star.active = false;
                        star.line.visible = false;
                        star.material.opacity = 0;
                    } else {
                        // æ›´æ–°æµæ˜Ÿé€æ˜åº¦
                        if (progress < 0.1) {
                            star.material.opacity = progress * 10;
                        } else if (progress > 0.8) {
                            star.material.opacity = (1 - progress) * 5;
                        } else {
                            star.material.opacity = 1;
                        }
                    }
                }
            });
        }

        // åˆ›å»ºç²¾ç¾ç¤¼ç‰©ç›’å­
        const giftBoxes = [];
        const giftBoxColors = ['#FF4444', '#44FF44', '#FFD700', '#FF88CC', '#FF1493', '#00CED1', '#FF8C00', '#9370DB']; // æ›´å¤šé¢œè‰²é€‰é¡¹

        function createGiftBox(color, photoIndex, size = 0.35, isGroundGift = false) {
            const boxSize = size; // ä½¿ç”¨ä¼ å…¥çš„å¤§å°å‚æ•°
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

            // åˆ›å»ºçº¹ç†
            const texture = createGiftBoxTexture(color);

            // ä½¿ç”¨MeshStandardMaterialå¢å¼ºå…‰ç…§æ•ˆæœï¼Œä½¿ç¤¼ç›’æ›´å…·ç«‹ä½“æ„Ÿ
            // å¯¹äºåœ°é¢ç¤¼ç›’ï¼Œä½¿ç”¨æ›´é«˜è´¨é‡çš„æè´¨å‚æ•°
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                depthTest: true,
                depthWrite: true,
                roughness: isGroundGift ? 0.15 : 0.3, // åœ°é¢ç¤¼ç›’æ›´å…‰æ»‘
                metalness: isGroundGift ? 0.25 : 0.1, // åœ°é¢ç¤¼ç›’ç¨å¾®å¢åŠ é‡‘å±æ„Ÿ
                emissive: new THREE.Color(0x000000), // è‡ªå‘å…‰é¢œè‰²
                emissiveIntensity: 0.1, // è‡ªå‘å…‰å¼ºåº¦
                envMapIntensity: isGroundGift ? 0.5 : 0.1, // ç¯å¢ƒè´´å›¾å¼ºåº¦ï¼Œåœ°é¢ç¤¼ç›’æ›´å¼º
                clearcoat: isGroundGift ? 0.3 : 0, // æ¸…æ¼†å±‚ï¼Œå¢åŠ å…‰æ³½æ„Ÿ
                clearcoatRoughness: isGroundGift ? 0.1 : 0 // æ¸…æ¼†ç²—ç³™åº¦
            });

            const box = new THREE.Mesh(geometry, material);
            box.castShadow = true;
            box.receiveShadow = true;
            // è®¾ç½®æ¸²æŸ“é¡ºåºï¼Œç¡®ä¿ç¤¼ç›’åœ¨ç²’å­å‰é¢
            box.renderOrder = isGroundGift ? 2 : 1;
            box.userData = {
                isGiftBox: false, // æ ‘ä¸Šçš„ç¤¼ç›’ä¸å¯ç‚¹å‡»
                isTreeDecoration: true, // æ ‡è¯†ä¸ºæ ‘ä¸Šè£…é¥°
                photoIndex: photoIndex,
                originalScale: 1,
                hoverScale: 1.2,
                isGroundGift: isGroundGift // æ ‡è¯†æ˜¯å¦ä¸ºåœ°é¢ç¤¼ç›’
            };

            // å¦‚æœæ˜¯åœ°é¢ç¤¼ç›’ï¼Œæ·»åŠ é¢å¤–çš„è£…é¥°å…ƒç´ 
            if (isGroundGift) {
                // æ·»åŠ ä¸å¸¦
                addRibbonToGift(box, color, boxSize);
            }

            return box;
        }

        // ä¸ºç¤¼ç›’æ·»åŠ ä¸å¸¦è£…é¥°
        function addRibbonToGift(giftBox, boxColor, boxSize) {
            // åˆ›å»ºæ¨ªå‘ä¸å¸¦
            const ribbonGeometry = new THREE.BoxGeometry(boxSize * 1.05, boxSize * 0.15, boxSize * 0.05);
            const ribbonMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF, // ç™½è‰²ä¸å¸¦
                roughness: 0.3,
                metalness: 0.1,
                clearcoat: 0.2,
                clearcoatRoughness: 0.1
            });
            const ribbon = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
            ribbon.position.y = boxSize * 0.35; // ç¨å¾®é ä¸Šçš„ä½ç½®
            ribbon.castShadow = true;
            ribbon.receiveShadow = true;
            giftBox.add(ribbon);

            // åˆ›å»ºçºµå‘ä¸å¸¦
            const verticalRibbonGeometry = new THREE.BoxGeometry(boxSize * 0.05, boxSize * 1.05, boxSize * 0.05);
            const verticalRibbon = new THREE.Mesh(verticalRibbonGeometry, ribbonMaterial);
            verticalRibbon.castShadow = true;
            verticalRibbon.receiveShadow = true;
            giftBox.add(verticalRibbon);

            // åˆ›å»ºè´è¶ç»“
            const bowGroup = createBow(boxSize * 0.3);
            bowGroup.position.y = boxSize * 0.45; // æ”¾åœ¨ç¤¼ç›’é¡¶éƒ¨
            bowGroup.position.z = boxSize * 0.03; // ç¨å¾®å‘å‰ä¸€ç‚¹
            giftBox.add(bowGroup);
        }

        // åˆ›å»ºè´è¶ç»“è£…é¥°
        function createBow(size) {
            const bowGroup = new THREE.Group();

            // åˆ›å»ºè´è¶ç»“ä¸»ä½“ï¼ˆä¸¤ä¸ªåœ†ç›˜ï¼‰
            const discGeometry = new THREE.CylinderGeometry(size * 0.3, size * 0.3, size * 0.05, 16);
            const discMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700, // é‡‘è‰²
                roughness: 0.2,
                metalness: 0.6,
                clearcoat: 0.3,
                clearcoatRoughness: 0.1
            });

            const leftDisc = new THREE.Mesh(discGeometry, discMaterial);
            leftDisc.position.x = -size * 0.25;
            leftDisc.castShadow = true;
            leftDisc.receiveShadow = true;
            bowGroup.add(leftDisc);

            const rightDisc = new THREE.Mesh(discGeometry, discMaterial);
            rightDisc.position.x = size * 0.25;
            rightDisc.castShadow = true;
            rightDisc.receiveShadow = true;
            bowGroup.add(rightDisc);

            // åˆ›å»ºè´è¶ç»“ä¸­å¿ƒ
            const centerGeometry = new THREE.SphereGeometry(size * 0.15, 16, 16);
            const center = new THREE.Mesh(centerGeometry, discMaterial);
            center.castShadow = true;
            center.receiveShadow = true;
            bowGroup.add(center);

            // åˆ›å»ºè´è¶ç»“é£˜å¸¦ï¼ˆç®€åŒ–ç‰ˆï¼‰
            const ribbonGeometry = new THREE.BoxGeometry(size * 0.05, size * 0.4, size * 0.02);
            const ribbonMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                roughness: 0.3,
                metalness: 0.3,
                clearcoat: 0.2,
                clearcoatRoughness: 0.1
            });

            const leftRibbon = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
            leftRibbon.position.x = -size * 0.15;
            leftRibbon.position.y = -size * 0.2;
            leftRibbon.rotation.z = Math.PI / 6;
            leftRibbon.castShadow = true;
            leftRibbon.receiveShadow = true;
            bowGroup.add(leftRibbon);

            const rightRibbon = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
            rightRibbon.position.x = size * 0.15;
            rightRibbon.position.y = -size * 0.2;
            rightRibbon.rotation.z = -Math.PI / 6;
            rightRibbon.castShadow = true;
            rightRibbon.receiveShadow = true;
            bowGroup.add(rightRibbon);

            return bowGroup;
        }

        // åœ¨åœ£è¯æ ‘ä¸Šéšæœºæ”¾ç½®å¤šä¸ªç¤¼ç›’ï¼Œå¢åŠ é«˜åº¦å’Œå„ç§å·®å¼‚æ€§
        function placeGiftBoxesOnTree() {
            const boxCount = 3; // ç¤¼ç›’æ•°é‡æ”¹ä¸º3ä¸ª
            const placedBoxes = []; // å­˜å‚¨å·²æ”¾ç½®çš„ç¤¼ç›’ä½ç½®ï¼Œç”¨äºæ£€æµ‹è·ç¦»

            for (let i = 0; i < boxCount; i++) {
                let attempts = 0; // å°è¯•æ¬¡æ•°ï¼Œé˜²æ­¢æ— é™å¾ªç¯
                let validPosition = false;
                let height, angle, finalRadius;

                // å°è¯•æ‰¾åˆ°ä¸€ä¸ªä¸ä¸å…¶ä»–ç¤¼ç›’å¤ªè¿‘çš„ä½ç½®
                while (!validPosition && attempts < 50) {
                    // éšæœºé€‰æ‹©é¢œè‰²
                    const colorIndex = Math.floor(Math.random() * giftBoxColors.length);
                    const color = giftBoxColors[colorIndex];

                    // éšæœºå¤§å°ï¼Œå¢åŠ å·®å¼‚æ€§
                    const size = 0.18 + Math.random() * 0.07; // å¤§å°èŒƒå›´ï¼š0.18åˆ°0.25

                    // åˆ›å»ºç¤¼ç›’
                    const giftBox = createGiftBox(color, i, size);

                    // é™åˆ¶åœ¨æ ‘çš„åº•éƒ¨åŒºåŸŸï¼Œé«˜åº¦èŒƒå›´ï¼š0.1åˆ°0.3
                    height = 0.1 + Math.random() * 0.2;

                    // å®Œå…¨éšæœºçš„è§’åº¦
                    angle = Math.random() * Math.PI * 2; // 0åˆ°360åº¦

                    // è®¡ç®—å½“å‰é«˜åº¦çš„æ ‘çš„åŠå¾„
                    const treeRadius = Math.max(0.1, 0.8 - height * 0.5); // æ ‘çš„åŠå¾„éšé«˜åº¦å‡å°

                    // ç¤¼ç›’åº”è¯¥é™„ç€åœ¨æ ‘çš„åº•éƒ¨è¡¨é¢ï¼Œç¡®ä¿ç¤¼ç›’å®Œå…¨åœ¨æ ‘çš„å¤–éƒ¨
                    // ç¤¼ç›’çš„ä¸­å¿ƒåº”è¯¥åœ¨æ ‘çš„åŠå¾„åŠ ä¸Šç¤¼ç›’å°ºå¯¸çš„ä¸€åŠï¼Œè¿™æ ·ç¤¼ç›’å°±ä¸ä¼šç©¿æ¨¡
                    const radius = treeRadius + size * 0.5; // ç¡®ä¿ç¤¼ç›’å®Œå…¨åœ¨æ ‘çš„å¤–éƒ¨

                    // å‡å°‘åŠå¾„éšæœºåç§»ï¼Œé¿å…ç¤¼ç›’ç¦»æ ‘å¤ªè¿œæˆ–ç©¿æ¨¡
                    const radiusVariation = (Math.random() - 0.5) * 0.1; // å‡å°åŠå¾„å˜åŒ–èŒƒå›´åˆ°Â±0.05
                    finalRadius = Math.max(treeRadius + size * 0.3, radius + radiusVariation); // ç¡®ä¿ç¤¼ç›’ä¸ä¼šç©¿æ¨¡

                    // è®¡ç®—å®é™…ä½ç½®
                    const x = Math.cos(angle) * finalRadius;
                    const z = Math.sin(angle) * finalRadius;

                    // æ£€æŸ¥ä¸å·²æ”¾ç½®ç¤¼ç›’çš„è·ç¦»
                    validPosition = true;
                    for (const box of placedBoxes) {
                        const distance = Math.sqrt(
                            Math.pow(x - box.x, 2) +
                            Math.pow(z - box.z, 2) +
                            Math.pow(height - box.y, 2) * 2 // é«˜åº¦å·®å¼‚æƒé‡åŠ å€
                        );

                        // å¦‚æœè·ç¦»å¤ªè¿‘ï¼Œåˆ™ä½ç½®æ— æ•ˆ
                        if (distance < 0.4) { // æœ€å°è·ç¦»é˜ˆå€¼
                            validPosition = false;
                            break;
                        }
                    }

                    attempts++;
                }

                // å¦‚æœæ‰¾åˆ°äº†æœ‰æ•ˆä½ç½®ï¼Œåˆ›å»ºç¤¼ç›’
                if (validPosition) {
                    // éšæœºé€‰æ‹©é¢œè‰²
                    const colorIndex = Math.floor(Math.random() * giftBoxColors.length);
                    const color = giftBoxColors[colorIndex];

                    // éšæœºå¤§å°ï¼Œå¢åŠ å·®å¼‚æ€§
                    const size = 0.25 + Math.random() * 0.3; // å¤§å°èŒƒå›´ï¼š0.25åˆ°0.55

                    // åˆ›å»ºç¤¼ç›’
                    const giftBox = createGiftBox(color, i, size);

                    giftBox.position.x = Math.cos(angle) * finalRadius;
                    giftBox.position.y = height;
                    giftBox.position.z = Math.sin(angle) * finalRadius;

                    // è®©ç¤¼ç›’é¢å‘å¤–éƒ¨ï¼Œè€Œä¸æ˜¯æœå‘æ ‘ä¸­å¿ƒ
                    // è®¡ç®—ç¤¼ç›’åº”è¯¥æœå‘çš„æ–¹å‘ï¼ˆä»æ ‘ä¸­å¿ƒå‘å¤–ï¼‰
                    const outwardDirection = new THREE.Vector3(giftBox.position.x, 0, giftBox.position.z).normalize();
                    // è®¾ç½®ç¤¼ç›’æœå‘ä¸ºå‘å¤–æ–¹å‘
                    giftBox.lookAt(
                        giftBox.position.x + outwardDirection.x,
                        giftBox.position.y,
                        giftBox.position.z + outwardDirection.z
                    );

                    // æ·»åŠ é€‚åº¦çš„éšæœºæ—‹è½¬ï¼Œä½¿æ¯ä¸ªç¤¼ç›’çœ‹èµ·æ¥æ›´è‡ªç„¶
                    giftBox.rotation.y += (Math.random() - 0.5) * Math.PI * 0.5; // å‡å°‘Yè½´æ—‹è½¬èŒƒå›´
                    giftBox.rotation.x += (Math.random() - 0.5) * 0.2; // å‡å°‘Xè½´æ—‹è½¬èŒƒå›´
                    giftBox.rotation.z += (Math.random() - 0.5) * 0.2; // å‡å°‘Zè½´æ—‹è½¬èŒƒå›´

                    // è®°å½•å·²æ”¾ç½®çš„ç¤¼ç›’ä½ç½®
                    placedBoxes.push({
                        x: giftBox.position.x,
                        y: giftBox.position.y,
                        z: giftBox.position.z
                    });

                    giftBoxes.push(giftBox);
                    // æ·»åŠ åˆ°particleGroupä¸­ï¼Œä½¿ç¤¼ç›’éšåœ£è¯æ ‘ä¸€èµ·æ—‹è½¬
                    particleGroup.add(giftBox);

                    console.log(`ç¤¼ç›’ ${i} å·²æ·»åŠ åˆ°åœºæ™¯ï¼Œä½ç½®:`, giftBox.position);
                }
            }
        }

        placeGiftBoxesOnTree();

        // é¼ æ ‡/è§¦æ‘¸æ§åˆ¶æ—‹è½¬
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = { x: 0, y: 0 };

        // é¼ æ ‡äº‹ä»¶
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ - æ·»åŠ ç¤¼ç‰©ç›’å­æ‚¬åœæ•ˆæœ
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                rotationSpeed.y = deltaX * 0.01;
                rotationSpeed.x = deltaY * 0.01;

                previousMousePosition = { x: e.clientX, y: e.clientY };
            } else {
                // æ£€æµ‹é¼ æ ‡æ‚¬åœåœ¨ç¤¼ç‰©ç›’å­ä¸Š
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // é‡ç½®é¼ æ ‡æ ·å¼
                document.body.style.cursor = 'grab';
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // è§¦æ‘¸äº‹ä»¶
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            previousMousePosition = { x: touch.clientX, y: touch.clientY };
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && e.touches.length > 0) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;

                rotationSpeed.y = deltaX * 0.01;
                rotationSpeed.x = deltaY * 0.01;

                previousMousePosition = { x: touch.clientX, y: touch.clientY };
            }
        });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });

        // ç‚¹å‡»æ£€æµ‹
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (e) => {
            console.log("ç‚¹å‡»äº‹ä»¶è§¦å‘ï¼Œé¼ æ ‡ä½ç½®:", e.clientX, e.clientY);

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.params.Points.threshold = 0.1; // å¢åŠ ç‚¹å¯¹è±¡çš„æ£€æµ‹é˜ˆå€¼

            // æš‚æ—¶ç§»é™¤å‰æ™¯é›ªèŠ±ï¼Œé˜²æ­¢é˜»æŒ¡ç‚¹å‡»äº‹ä»¶
            let foregroundSnow = scene.children.find(child => child instanceof THREE.Points && child.renderOrder === 0);
            if (foregroundSnow) {
                scene.remove(foregroundSnow);
            }

            // æ£€æµ‹ç™½è‰²äº”è§’æ˜Ÿçš„ç‚¹å‡»
            const starIntersects = raycaster.intersectObjects([treeStar], true);
            if (starIntersects.length > 0) {
                // è§¦å‘åœ£è¯æ ‘æ•£å¼€å˜æˆæ˜Ÿç©ºçš„ç‰¹æ•ˆ
                transformTreeToStarfield();
                // æ¢å¤å‰æ™¯é›ªèŠ±
                if (foregroundSnow) scene.add(foregroundSnow);
                return;
            }

            // æ£€æµ‹çº¢è‰²ç¤¼ç‰©ç²’å­çš„ç‚¹å‡»ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼‰
            const intersects = raycaster.intersectObjects(giftMeshes);
            if (intersects.length > 0) {
                const gift = intersects[0].object;
                showPhoto(gift.userData.index);
            }

            // æ£€æµ‹åœ°é¢ç¤¼ç›’çš„ç‚¹å‡»
            const groundGiftIntersects = raycaster.intersectObjects(groundGifts);
            if (groundGiftIntersects.length > 0) {
                const gift = groundGiftIntersects[0].object;
                openGroundGift3D(gift.userData.index);
            }

            // æ¢å¤å‰æ™¯é›ªèŠ±
            if (foregroundSnow) scene.add(foregroundSnow);
        });











        // æ˜¾ç¤ºç…§ç‰‡
        const photoFrame = document.getElementById('photoFrame');
        const photoImg = document.getElementById('photoImg');
        const closeBtn = document.getElementById('closeBtn');
        const letterPopup = document.getElementById('letterPopup');
        const letterClose = document.getElementById('letterClose');
        let isPhotoOpen = false;

        const photos = [
            'img/xiaohan2.jpg',
            'img/xiaohan3.jpg',
            'img/xiaohan1.jpg',
            // 'img/xiaohan1.jpg'
        ];

        function showPhoto(index) {
            photoImg.src = photos[index % photos.length];

            const angles = ['angle-1', 'angle-2', 'angle-3', 'angle-4', 'angle-5', 'angle-6'];
            const randomAngle = angles[Math.floor(Math.random() * angles.length)];

            photoFrame.className = 'photo-frame ' + randomAngle;
            photoFrame.classList.add('show');
            isPhotoOpen = true;
        }

        // æ‰“å­—æœºæ•ˆæœå‡½æ•°
        function typeWriter(element, text, speed = 100) {
            element.innerHTML = '';
            element.classList.remove('typing-done');
            let i = 0;

            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    element.classList.add('typing-done');
                }
            }

            type();
        }

        // 3Dåœ°é¢ç¤¼ç›’ç‚¹å‡»å¤„ç†å‡½æ•°
        function openGroundGift3D(giftIndex) {
            const gift = groundGifts.find(g => g.userData.index === giftIndex);
            if (gift) {
                // å¦‚æœå·²ç»åœ¨åŠ¨ç”»ä¸­ï¼Œåˆ™ä¸é‡å¤è§¦å‘
                if (gift.userData.isAnimating) return;
                gift.userData.isAnimating = true;

                const initialScale = { x: gift.scale.x, y: gift.scale.y, z: gift.scale.z };
                const initialRotation = { x: gift.rotation.x, y: gift.rotation.y, z: gift.rotation.z };
                const initialPosition = { x: gift.position.x, y: gift.position.y, z: gift.position.z };

                const startTime = Date.now();
                const duration = 1200;

                const flashLight = new THREE.PointLight(0xffffff, 1.5, 3);
                flashLight.position.set(gift.position.x, gift.position.y + 0.5, gift.position.z);
                scene.add(flashLight);

                const particleCount = 150;
                const particles = [];
                const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const particleColors = [0xFFFF00, 0xFF0000, 0x00FF00, 0x0000FF, 0xFF00FF, 0xFFA500, 0x00FFFF, 0xFF1493];

                for (let i = 0; i < particleCount; i++) {
                    const particleMaterial = new THREE.MeshStandardMaterial({
                        color: particleColors[Math.floor(Math.random() * particleColors.length)],
                        emissive: particleColors[Math.floor(Math.random() * particleColors.length)],
                        emissiveIntensity: 0.5,
                        roughness: 0.1,
                        metalness: 0.9
                    });

                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(gift.position);

                    const speed = 3 + Math.random() * 3;
                    const angle = Math.random() * Math.PI * 2;
                    const verticalAngle = Math.random() * Math.PI - Math.PI / 2;

                    particle.userData = {
                        velocity: new THREE.Vector3(
                            Math.sin(angle) * Math.cos(verticalAngle) * speed,
                            Math.abs(Math.sin(verticalAngle)) * speed,
                            Math.cos(angle) * Math.cos(verticalAngle) * speed
                        ),
                        life: 1.0,
                        initialScale: 1 + Math.random() * 0.5
                    };
                    particle.scale.setScalar(particle.userData.initialScale);
                    scene.add(particle);
                    particles.push(particle);
                }

                function giftAnimate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    if (progress < 0.25) {
                        const subProgress = progress / 0.25;
                        const easeSub = 1 - Math.pow(1 - subProgress, 2);

                        gift.scale.set(
                            initialScale.x * (1 + easeSub * 0.15),
                            initialScale.y * (1 + easeSub * 0.15),
                            initialScale.z * (1 + easeSub * 0.15)
                        );

                        gift.position.y = initialPosition.y + easeSub * 0.15;
                        gift.rotation.y = initialRotation.y + easeSub * 0.2;
                    }
                    else if (progress < 0.6) {
                        const subProgress = (progress - 0.25) / 0.35;
                        const easeSub = 1 - Math.pow(1 - subProgress, 3);

                        gift.scale.y = initialScale.y * (1 - easeSub * 0.4);
                        gift.rotation.y = initialRotation.y + easeSub * Math.PI * 1.2;
                        gift.position.y = initialPosition.y + 0.15 - easeSub * 0.15;
                        flashLight.intensity = 1.5 + easeSub * 3;
                    }
                    else {
                        const subProgress = (progress - 0.6) / 0.4;
                        const bounce = Math.pow(Math.sin(subProgress * Math.PI), 2) * 0.15;

                        gift.scale.set(
                            initialScale.x * (1 + bounce * 0.5),
                            initialScale.y * (0.6 + bounce),
                            initialScale.z * (1 + bounce * 0.5)
                        );

                        gift.rotation.y = initialRotation.y + Math.PI * 1.2;
                        gift.position.y = initialPosition.y - 0.4 * (1 - subProgress) + bounce;
                        flashLight.intensity = 4.5 * (1 - subProgress * 0.8);
                    }

                    for (let i = particles.length - 1; i >= 0; i--) {
                        const particle = particles[i];
                        particle.userData.life -= 0.015;

                        if (particle.userData.life <= 0) {
                            scene.remove(particle);
                            particles.splice(i, 1);
                        } else {
                            particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.08));
                            particle.userData.velocity.y -= 0.04;
                            particle.userData.velocity.multiplyScalar(0.98);

                            particle.material.opacity = particle.userData.life;
                            particle.material.emissiveIntensity = particle.userData.life * 0.8;

                            const scale = particle.userData.initialScale * (0.5 + particle.userData.life * 0.5);
                            particle.scale.setScalar(scale);
                        }
                    }

                    if (progress < 1) {
                        requestAnimationFrame(giftAnimate);

                        if (progress > 0.6) {
                            if (giftIndex === 4) {
                                if (!letterPopup.classList.contains('show')) {
                                    const letterText = document.querySelector('.letter-text');
                                    letterText.innerHTML = '';
                                    letterText.classList.remove('typing-done');

                                    letterPopup.classList.add('show');
                                    createScatteredParticles();
                                    setTimeout(() => {
                                        letterPopup.classList.add('visible');
                                    }, 100);

                                    setTimeout(() => {
                                        const fullText = "æˆ‘ä¸€ç›´æ˜ç™½ä½ æ˜¯ä¸€ä¸ªå¾ˆéœ€è¦å®‰å…¨æ„Ÿçš„äººã€‚æˆ‘å®Œå…¨ç†è§£ä½ çš„èƒ†æ€¯ï¼Œé‡åˆ°ä½ ä¹‹å‰ï¼Œæˆ‘ä¹Ÿä¸æƒ³ä»»ä½•äººæ‰“ä¹±è‡ªå·±å¹³é™å¹³å’Œèˆ’é€‚çš„ç”Ÿæ´»èŠ‚å¥ï¼Œæˆ‘ä¹Ÿæœ‰ä¸€å µå°çŸ®å¢™ï¼Œå°±åƒä½ æœ‰ä¸ªç»“ç•Œã€‚é‚£æ˜¯ä¸€ç§è‡ªæˆ‘ä¿æŠ¤çš„å®‰å…¨æ„Ÿï¼Œå°±åƒæˆ‘å°æ—¶å€™å–œæ¬¢æŠŠè‡ªå·±â€œå…³â€åœ¨ä¸€ä¸ªå°å°çš„ç©ºé—´é‡Œï¼Œå¿ƒé‡Œæƒ³ç€åˆ«äººè¿›ä¸æ¥ï¼Œè¿™æ˜¯æˆ‘æœ€å®‰å…¨æœ€æ”¾æ¾çš„åœ°æ–¹ã€‚ä½†æ˜¯ï¼Œå› ä¸ºæ˜¯ä½ å•Šï¼é¢œè‹¥è¡å•Šï¼æˆ‘å…ˆå¸ä¸‹é˜²å¤‡ï¼Œæˆ‘ä¸æ€•ï¼Œæˆ‘ä¸€ç‚¹ä¹Ÿä¸æ€•ã€‚å“ˆå“ˆå“ˆå“ˆå“ˆç»†è…»çš„äººå¤©ç”Ÿä¼šæŠŠçœŸå¿ƒè£¹çš„æ›´ç´§ã€‚å…¶å®ä¸ç”¨å®³æ€•å¦è¯šä¹‹åçš„åœ†æ»¡ä¸‹æ–‡ã€‚èƒ½æ„¿æ„æŠŠè‡ªå·±çš„å¿ƒåº•çš„è¯å‘Šè¯‰æˆ‘ï¼Œå¯¹æˆ‘æ¥è¯´å·²ç»æ˜¯å¾ˆçè´µçš„äº‹æƒ…äº†ï¼é‚£ï¼Œæˆ‘ä»¬ä¸€èµ·å‹‡æ•¢å‰è¡Œå§ã€‚æ²¿é€”ï¼Œä½ å°±æ˜¯æœ€ç¾çš„é£æ™¯ï¼ â¤ï¸";
                                        typeWriter(letterText, fullText, 150);
                                    }, 1200);
                                }
                            } else {
                                if (!photoFrame.classList.contains('show')) {
                                    showPhoto(giftIndex - 1);
                                    setTimeout(() => {
                                        photoFrame.classList.add('visible');
                                    }, 100);
                                }
                            }
                        }
                    } else {
                        scene.remove(flashLight);
                        particles.forEach(particle => scene.remove(particle));
                        // åŠ¨ç”»ç»“æŸåï¼Œé‡ç½®ç¤¼ç›’çŠ¶æ€ï¼Œä½¿å…¶å¯ä»¥å†æ¬¡ç‚¹å‡»
                        setTimeout(() => {
                            gift.userData.isAnimating = false;
                            // æ¢å¤åŸå§‹æ¯”ä¾‹ï¼ˆå¯é€‰ï¼Œå¦‚æœä¸æ¢å¤åˆ™ä¿æŒæ‰“å¼€çŠ¶æ€ï¼‰
                            // gift.scale.copy(initialScale);
                            // gift.position.copy(initialPosition);
                            // gift.rotation.copy(initialRotation);
                        }, 500);
                    }
                }

                giftAnimate();
            }
        }

        closeBtn.addEventListener('click', () => {
            photoFrame.classList.remove('visible');
            setTimeout(() => {
                photoFrame.classList.remove('show');
                isPhotoOpen = false;
            }, 1200);
        });

        letterClose.addEventListener('click', () => {
            letterPopup.classList.remove('visible');
            setTimeout(() => {
                letterPopup.classList.remove('show');
                // æ¸…ç©ºæ–‡å­—ï¼Œæ–¹ä¾¿ä¸‹æ¬¡é‡æ–°å¼€å§‹æ‰“å­—åŠ¨æ•ˆ
                document.querySelector('.letter-text').innerHTML = '';
            }, 1200);
        });

        function createScatteredParticles() {
            const particles = ['â¤ï¸', 'ğŸŒ¹', 'ğŸŒ¸', 'âœ¨', 'ğŸ’–'];
            const count = 30;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'scatter-particle';
                particle.textContent = particles[Math.floor(Math.random() * particles.length)];

                // éšæœºæ•£å°„å‚æ•°
                const angle = Math.random() * Math.PI * 2;
                const distance = 150 + Math.random() * 300;
                const tx = (Math.cos(angle) * distance) + 'px';
                const ty = (Math.sin(angle) * distance) + 'px';
                const scale = 0.5 + Math.random() * 1.5;
                const rot = (Math.random() * 360) + 'deg';
                const duration = 1.5 + Math.random() * 1.5;

                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.setProperty('--tx', tx);
                particle.style.setProperty('--ty', ty);
                particle.style.setProperty('--scale', scale);
                particle.style.setProperty('--rot', rot);
                particle.style.animation = `scatter ${duration}s cubic-bezier(0.12, 0.89, 0.32, 1) forwards`;

                document.body.appendChild(particle);

                // åŠ¨ç”»ç»“æŸåç§»é™¤å…ƒç´ 
                setTimeout(() => {
                    particle.remove();
                }, duration * 1000);
            }
        }

        // åœ£è¯æ ‘æ•£å¼€å˜æˆæ˜Ÿç©ºçš„ç‰¹æ•ˆ
        let isTransforming = false;
        let isStarfield = false;
        let originalTreePositions = [];
        let starfieldAnimation = null;

        function transformTreeToStarfield() {
            if (isTransforming) return; // é˜²æ­¢é‡å¤è§¦å‘
            isTransforming = true;

            // ä¿å­˜åŸå§‹æ ‘ç²’å­ä½ç½®
            if (!isStarfield) {
                // å˜æˆæ˜Ÿç©º
                originalTreePositions = [];

                // éå†particleGroupä¸­çš„æ‰€æœ‰ç²’å­å¯¹è±¡
                particleGroup.children.forEach(child => {
                    if (child instanceof THREE.Points &&
                        child.geometry.attributes.position &&
                        child.geometry.attributes.color) {
                        const particles = child.geometry.attributes.position.array;
                        const colors = child.geometry.attributes.color.array;

                        // ä¿å­˜æ¯ä¸ªç²’å­å¯¹è±¡çš„ä½ç½®å’Œé¢œè‰²
                        const positions = [];
                        const originalColors = [];

                        for (let i = 0; i < particles.length; i += 3) {
                            positions.push({
                                x: particles[i],
                                y: particles[i + 1],
                                z: particles[i + 2]
                            });

                            originalColors.push({
                                r: colors[i],
                                g: colors[i + 1],
                                b: colors[i + 2]
                            });
                        }

                        originalTreePositions.push({
                            points: child,
                            positions: positions,
                            colors: originalColors
                        });
                    }
                });

                // åˆ›å»ºæ˜Ÿç©ºåŠ¨ç”»
                starfieldAnimation = {
                    progress: 0,
                    duration: 3000, // 3ç§’åŠ¨ç”»
                    startTime: Date.now()
                };

                // éšè—ç¤¼ç›’
                giftBoxes.forEach(box => {
                    box.visible = false;
                });

                // æ”¹å˜èƒŒæ™¯ä¸ºæ·±è“è‰²å¤œç©º
                document.body.style.background = 'radial-gradient(ellipse at center, #0a1551 0%, #000000 100%)';

                // æ˜¾ç¤ºé‡ç½®æŒ‰é’®ï¼Œéšè—æ˜Ÿç©ºæŒ‰é’®
                document.getElementById('resetBtn').style.display = 'block';
                document.getElementById('starfieldBtn').style.display = 'none';
            } else {
                // å˜å›åœ£è¯æ ‘
                starfieldAnimation = {
                    progress: 0,
                    duration: 3000,
                    startTime: Date.now(),
                    reverse: true
                };

                // æ˜¾ç¤ºç¤¼ç›’
                giftBoxes.forEach(box => {
                    box.visible = true;
                });

                // æ¢å¤åŸå§‹èƒŒæ™¯
                document.body.style.background = 'radial-gradient(ellipse at center, #1a2a6c 0%, #0a0e27 100%)';

                // éšè—é‡ç½®æŒ‰é’®ï¼Œæ˜¾ç¤ºæ˜Ÿç©ºæŒ‰é’®
                document.getElementById('resetBtn').style.display = 'none';
                document.getElementById('starfieldBtn').style.display = 'flex';
            }

            // æ›´æ–°åŠ¨ç”»çŠ¶æ€
            isStarfield = !isStarfield;

            // æ˜¾ç¤ºæˆ–éšè—é‡ç½®æŒ‰é’®
            document.getElementById('resetBtn').style.display = isStarfield ? 'block' : 'none';
        }

        // é‡ç½®åœºæ™¯å‡½æ•°
        function resetScene() {
            if (isStarfield) {
                transformTreeToStarfield(); // å†æ¬¡è°ƒç”¨ä¼šå˜å›åœ£è¯æ ‘
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // å¤„ç†æ˜Ÿç©ºåŠ¨ç”»
            if (starfieldAnimation) {
                const elapsed = Date.now() - starfieldAnimation.startTime;
                const progress = Math.min(elapsed / starfieldAnimation.duration, 1);

                if (progress >= 1) {
                    // åŠ¨ç”»å®Œæˆ
                    starfieldAnimation = null;
                    isTransforming = false;
                } else {
                    // æ›´æ–°ç²’å­ä½ç½®å’Œé¢œè‰²
                    originalTreePositions.forEach(objData => {
                        if (objData.points &&
                            objData.points.geometry &&
                            objData.points.geometry.attributes.position &&
                            objData.points.geometry.attributes.color) {
                            const particles = objData.points.geometry.attributes.position.array;
                            const colors = objData.points.geometry.attributes.color.array;

                            for (let i = 0; i < objData.positions.length; i++) {
                                const idx = i * 3;
                                const original = objData.positions[i];
                                const originalColor = objData.colors[i];

                                if (starfieldAnimation.reverse) {
                                    // å˜å›åœ£è¯æ ‘
                                    particles[idx] = original.x;
                                    particles[idx + 1] = original.y;
                                    particles[idx + 2] = original.z;

                                    // æ¢å¤åŸå§‹é¢œè‰²
                                    colors[idx] = originalColor.r;
                                    colors[idx + 1] = originalColor.g;
                                    colors[idx + 2] = originalColor.b;
                                } else {
                                    // å˜æˆæ˜Ÿç©º
                                    // æ‰©æ•£åˆ°æ›´å¤§çš„ç©ºé—´
                                    const spreadRadius = 10 + Math.random() * 5;
                                    const theta = Math.random() * Math.PI * 2;
                                    const phi = Math.random() * Math.PI;

                                    particles[idx] = spreadRadius * Math.sin(phi) * Math.cos(theta);
                                    particles[idx + 1] = spreadRadius * Math.sin(phi) * Math.sin(theta) - 5; // å‘ä¸Šåç§»
                                    particles[idx + 2] = spreadRadius * Math.cos(phi);

                                    // å˜æˆæ˜Ÿæ˜Ÿé¢œè‰²ï¼ˆç™½è‰²ã€é»„è‰²ã€è“è‰²ç­‰ï¼‰
                                    const starType = Math.random();
                                    if (starType < 0.3) {
                                        // ç™½è‰²æ˜Ÿæ˜Ÿ
                                        colors[idx] = 0.9 + Math.random() * 0.1;
                                        colors[idx + 1] = 0.9 + Math.random() * 0.1;
                                        colors[idx + 2] = 0.9 + Math.random() * 0.1;
                                    } else if (starType < 0.6) {
                                        // é»„è‰²æ˜Ÿæ˜Ÿ
                                        colors[idx] = 1.0;
                                        colors[idx + 1] = 0.9 + Math.random() * 0.1;
                                        colors[idx + 2] = 0.3 + Math.random() * 0.2;
                                    } else {
                                        // è“è‰²æ˜Ÿæ˜Ÿ
                                        colors[idx] = 0.3 + Math.random() * 0.2;
                                        colors[idx + 1] = 0.5 + Math.random() * 0.2;
                                        colors[idx + 2] = 0.9 + Math.random() * 0.1;
                                    }
                                }
                            }

                            // æ›´æ–°å‡ ä½•ä½“
                            objData.points.geometry.attributes.position.needsUpdate = true;
                            objData.points.geometry.attributes.color.needsUpdate = true;

                            // æ·»åŠ æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœ
                            if (!starfieldAnimation.reverse) {
                                const time = Date.now() * 0.001;
                                objData.points.material.size = 0.05 + Math.sin(time * 2 + Math.random() * 10) * 0.02;
                                objData.points.material.opacity = 0.7 + Math.sin(time * 3 + Math.random() * 10) * 0.3;
                            }
                        }
                    });
                }
            }

            // æ›´æ–°æµæ˜Ÿæ•ˆæœï¼ˆä»…åœ¨æ˜Ÿç©ºçŠ¶æ€ä¸‹ï¼‰
            if (isStarfield) {
                updateShootingStars();
            }

            // å¹³æ»‘æ—‹è½¬
            if (!isDragging) {
                rotationSpeed.y *= 0.95;
            }

            // åªå…è®¸ç»•Yè½´æ—‹è½¬ï¼ˆæ ‘å¹²ä¸­å¿ƒè½´ï¼‰ï¼Œç¦æ­¢Xè½´ç¿»è½¬
            particleGroup.rotation.y += rotationSpeed.y + 0.001; // æ·»åŠ æŒç»­ç¼“æ…¢æ—‹è½¬

            // ç§»é™¤Xè½´æ—‹è½¬ï¼Œä½¿åœ£è¯æ ‘åªèƒ½é¡ºæ—¶é’ˆ/é€†æ—¶é’ˆæ—‹è½¬
            particleGroup.rotation.x = 0;

            const time = Date.now() * 0.001;

            // ä¼˜åŒ–ç¤¼ç‰©é—ªçƒæ•ˆæœ - å‡å°‘çªå…€æ„Ÿ
            giftMeshes.forEach((gift, index) => {
                gift.material.opacity = 0.7 + Math.sin(time * 2 + index * 0.5) * 0.15;
                gift.scale.setScalar(1 + Math.sin(time * 1.5 + index * 0.5) * 0.08);
            });

            stars.rotation.y += 0.0001;
            stars.rotation.x += 0.00005;
            stars.material.opacity = 0.6 + Math.sin(time * 0.2) * 0.05;
            stars.position.y -= 0.002;

            if (stars.position.y < -5) {
                stars.position.y = 5;
            }

            stars.position.x = Math.sin(time * 0.1) * 0.3;

            foregroundSnow.rotation.y += 0.0001;
            foregroundSnow.rotation.x += 0.00005;
            foregroundSnow.position.y -= 0.003;

            if (foregroundSnow.position.y < -5) {
                foregroundSnow.position.y = 5;
            }

            foregroundSnow.position.x = Math.sin(time * 0.15) * 0.4;
            foregroundSnow.material.opacity = 0.7 + Math.sin(time * 0.2) * 0.05;

            // ç¤¼ç‰©ç›’å­åŠ¨ç”»
            giftBoxes.forEach((box, index) => {
                // è½»å¾®å·¦å³æ™ƒåŠ¨ï¼Œä¸è¦ç¿»æ»š
                const swayAmount = 0.05; // æ™ƒåŠ¨å¹…åº¦
                const swaySpeed = 0.001 + index * 0.0002; // æ¯ä¸ªç›’å­ç•¥æœ‰ä¸åŒçš„é€Ÿåº¦
                box.rotation.y = Math.sin(Date.now() * swaySpeed) * swayAmount;

                // è½»å¾®ä¸Šä¸‹æµ®åŠ¨
                const floatAmount = 0.02;
                const floatSpeed = 0.0008 + index * 0.0001;
                box.position.y += Math.sin(Date.now() * floatSpeed) * floatAmount * 0.01;
            });

            // åœ°é¢ç¤¼ç›’åŠ¨ç”»
            groundGifts.forEach((gift, index) => {
                // è½»å¾®æ‘‡æ‘†
                const swayAmount = 0.02;
                const swaySpeed = 0.0008 + index * 0.0002;
                gift.rotation.y = Math.sin(Date.now() * swaySpeed) * swayAmount;
            });

            // æ ‘ä¸Šå°ç¤¼ç›’åŠ¨ç”»
            treeGifts.forEach((gift, index) => {
                // è½»å¾®æ—‹è½¬
                gift.rotation.x += 0.003;
                gift.rotation.y += 0.002;
            });

            // é¡¶ç«¯äº”è§’æ˜Ÿä¿æŒå®Œå…¨é™æ­¢

            // ç»¿è‰²ç²’å­é—ªçƒæ•ˆæœ
            const greenParticles = particleGroup.children.find(child =>
                child instanceof THREE.Points &&
                child.material &&
                child.material.color &&
                child.material.color.getHex() === 0x00FF00
            );

            if (greenParticles) {
                greenParticles.material.opacity = 0.5 + Math.sin(time * 3) * 0.2;
                greenParticles.material.size = 0.12 + Math.sin(time * 2) * 0.03;
            }

            // æ›´æ–°ç¤¼ç›’ç‚¹å‡»æ¡†ä½ç½®
            updateGiftClickZones();

            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateGiftClickZones();
        });

        // åœ°é¢ç¤¼ç›’ç‚¹å‡»å¤„ç†å‡½æ•°

        // æ›´æ–°ç¤¼ç›’ç‚¹å‡»æ¡†ä½ç½®
        function updateGiftClickZones() {
            for (let i = 0; i < groundGifts.length; i++) {
                const gift = groundGifts[i];
                const clickZone = document.getElementById('giftClick' + (i + 1));

                if (gift && clickZone) {
                    // è·å–ç¤¼ç›’çš„ä¸–ç•Œåæ ‡
                    const giftPosition = new THREE.Vector3();
                    gift.getWorldPosition(giftPosition);

                    // æŠ•å½±åˆ°å±å¹•åæ ‡
                    const screenPosition = giftPosition.clone().project(camera);

                    // è½¬æ¢ä¸ºCSSåƒç´ åæ ‡
                    const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;

                    // è¾¹ç•Œæ£€æŸ¥ï¼šå¦‚æœç‚¹å‡»æ¡†åœ¨è§†å£å¤–ï¼Œåˆ™éšè—
                    if (x < -40 || x > window.innerWidth + 40 || y < -40 || y > window.innerHeight + 40) {
                        clickZone.style.display = 'none';
                        continue;
                    }

                    // è®¾ç½®ç‚¹å‡»æ¡†ä½ç½®ï¼ˆä½¿ç”¨ transform ä»£æ›¿ left/topï¼Œæ€§èƒ½æ›´å¥½ä¸”ä¸ä¼šè§¦å‘é‡æ’ï¼‰
                    clickZone.style.display = 'flex';
                    clickZone.style.left = '0';
                    clickZone.style.top = '0';
                    clickZone.style.transform = `translate(${x - 40}px, ${y - 40}px)`;
                } else if (clickZone) {
                    clickZone.style.display = 'none';
                }
            }
        }

        // å¯†ç é” 3D åœºæ™¯
        let overlayScene, overlayCamera, overlayRenderer, overlayTree, overlayFire, overlaySnow, overlayAurora;
        let treeLights = [];
        const overlayContainer = document.getElementById('overlay-canvas-container');

        function initOverlay3D() {
            if (!overlayContainer) return;

            overlayScene = new THREE.Scene();
            overlayCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            overlayCamera.position.set(0, 2, 8);
            overlayCamera.lookAt(0, 1, 0);

            overlayRenderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            overlayRenderer.setClearColor(0x000000, 0);
            overlayRenderer.setSize(window.innerWidth, window.innerHeight);
            overlayRenderer.setPixelRatio(window.devicePixelRatio);
            overlayContainer.appendChild(overlayRenderer.domElement);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            overlayScene.add(ambientLight);

            // ç¯ç«çš„å…‰
            const fireLight = new THREE.PointLight(0xff6600, 8, 25);
            fireLight.position.set(0.8, 0.5, 0.8);
            overlayScene.add(fireLight);

            // æå…‰èƒŒæ™¯
            createOverlayAurora();

            // é”¥å½¢æ¾é’ˆæ ‘
            createOverlayTree();

            // ç¯ç«
            createOverlayFire();

            // åœ°é¢æ¾é’ˆåœ°æ¯¯
            createOverlayCarpet();

            // é›ªèŠ±
            createOverlaySnow();

            // åœ°é¢
            const groundGeo = new THREE.PlaneGeometry(40, 40);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 1,
                metalness: 0
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            overlayScene.add(ground);

            animateOverlay();
        }

        function createOverlayCarpet() {
            const needleCount = 8000; // è¿›ä¸€æ­¥å¢åŠ æ•°é‡ä»¥è¾¾åˆ°æ›´åšå®çš„â€œé“ºæ»¡â€æ•ˆæœ
            const needleGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.12, 3);
            const needleMat = new THREE.MeshStandardMaterial({
                roughness: 0.9,
                metalness: 0
            });

            const instancedMesh = new THREE.InstancedMesh(needleGeo, needleMat, needleCount);
            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            for (let i = 0; i < needleCount; i++) {
                // ä¸‰ç§åˆ†å¸ƒï¼šå¤§éƒ¨åˆ†åœ¨æ ‘ä¸‹ï¼Œä¸€éƒ¨åˆ†åœ¨ç¯ç«æ—ï¼Œå…¶ä½™éšæœºæ•£å¸ƒ
                let x, z;
                const randDist = Math.random();
                if (randDist > 0.4) {
                    // æ ‘ä¸‹é›†ä¸­åˆ†å¸ƒ (å¯†åº¦æœ€é«˜)
                    const r = Math.sqrt(Math.random()) * 4.5;
                    const theta = Math.random() * Math.PI * 2;
                    x = Math.cos(theta) * r - 1.6;
                    z = Math.sin(theta) * r - 1.0;
                } else if (randDist > 0.15) {
                    // ç¯ç«æ—åˆ†å¸ƒ
                    const r = Math.sqrt(Math.random()) * 2.5;
                    const theta = Math.random() * Math.PI * 2;
                    x = Math.cos(theta) * r + 0.8;
                    z = Math.sin(theta) * r + 0.8;
                } else {
                    // å…¨åœºéšæœºæ•£å¸ƒ
                    x = (Math.random() - 0.5) * 18;
                    z = (Math.random() - 0.5) * 18;
                }

                // ç¨å¾®éšæœºåŒ–é«˜åº¦ï¼Œé˜²æ­¢é‡å å¯¼è‡´çš„é—ªçƒ(Z-fighting)ï¼Œå¹¶å¢åŠ åšåº¦æ„Ÿ
                const y = -0.495 + Math.random() * 0.01;
                const position = new THREE.Vector3(x, y, z);

                // éšæœºæ—‹è½¬ï¼šå¤§éƒ¨åˆ†å¹³é“ºï¼Œå°‘æ•°æ–œç€
                const rotation = new THREE.Euler(
                    Math.PI / 2 + (Math.random() - 0.5) * 0.4, // å¢åŠ ä¿¯ä»°è§’çš„éšæœºæ€§ï¼Œæ¨¡æ‹Ÿå±‚å 
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.2
                );

                const scale = new THREE.Vector3().setScalar(0.5 + Math.random() * 0.9);

                const quaternion = new THREE.Quaternion().setFromEuler(rotation);
                matrix.compose(position, quaternion, scale);
                instancedMesh.setMatrixAt(i, matrix);

                // é¢œè‰²å˜åŒ–ï¼šæ·±ç»¿ä¸ºä¸»ï¼Œå¤¹æ‚æ¯é»„å’Œå—ç«å…‰å½±å“çš„æš–è‰²æ„Ÿ
                const randColor = Math.random();
                if (randColor > 0.92) {
                    color.setHex(0x4d3319); // è¾ƒæ·±çš„æ¯è¤è‰²
                } else if (randColor > 0.85) {
                    color.setHex(0x856600); // æ¯é»„è‰²
                } else if (randColor > 0.4) {
                    color.setHex(0x132613); // ææ·±ç»¿
                } else {
                    color.setHex(0x1a331a); // æ ‡å‡†æ·±ç»¿
                }
                instancedMesh.setColorAt(i, color);
            }

            overlayScene.add(instancedMesh);
        }

        function createOverlayAurora() {
            const auroraCount = 3;
            const auroraGroup = new THREE.Group();

            for (let i = 0; i < auroraCount; i++) {
                const geo = new THREE.PlaneGeometry(30, 15, 20, 20);
                const mat = new THREE.MeshBasicMaterial({
                    color: i === 0 ? 0x00ff99 : (i === 1 ? 0x0066ff : 0x9900ff),
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const aurora = new THREE.Mesh(geo, mat);
                aurora.position.z = -15 - i * 2;
                aurora.position.y = 10;
                aurora.rotation.x = Math.PI / 4;
                auroraGroup.add(aurora);
            }

            overlayScene.add(auroraGroup);
            overlayAurora = auroraGroup;
        }

        function createOverlayTree() {
            const treeGroup = new THREE.Group();

            // æ ‘å¹² - ç¨å¾®åŠ ç²—å¹¶å¢åŠ çº¹ç†æ„Ÿ
            const trunkGeo = new THREE.CylinderGeometry(0.15, 0.22, 1.8, 12);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x2d1b0e,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = -0.1;
            treeGroup.add(trunk);

            // æ¾é’ˆå±‚ - å‡å°‘å±‚æ•°ï¼Œå¢åŠ å•å±‚å¤æ‚åº¦
            const layers = 7;
            const leafColors = [0x1a331a, 0x244024, 0x1e3a1e];

            for (let i = 0; i < layers; i++) {
                const ratio = i / layers;
                const layerRadius = 2.8 * (1 - ratio * 0.9);
                const layerHeight = 1.0;
                const layerY = 0.4 + i * 0.65;

                // 1. ä¸»å¶ç‰‡ç°‡ (æ¯ä¸€å±‚ç”±å¤šä¸ªæ—‹è½¬çš„å°å—ç»„æˆï¼Œä¸å†æ˜¯å•çº¯çš„åœ†é”¥)
                const clusterGroup = new THREE.Group();
                const subClusters = 8;
                for (let k = 0; k < subClusters; k++) {
                    const subGeo = new THREE.ConeGeometry(layerRadius * 0.6, layerHeight, 4, 1);
                    const subMat = new THREE.MeshStandardMaterial({
                        color: leafColors[i % 3],
                        roughness: 0.8,
                        flatShading: true
                    });
                    const subLeaf = new THREE.Mesh(subGeo, subMat);
                    const angle = (k / subClusters) * Math.PI * 2;
                    const dist = layerRadius * 0.4;
                    subLeaf.position.set(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
                    subLeaf.rotation.y = angle;
                    subLeaf.rotation.x = 0.2 + Math.random() * 0.2;
                    clusterGroup.add(subLeaf);
                }
                clusterGroup.position.y = layerY;
                treeGroup.add(clusterGroup);

                // 2. æ›´åŠ å¯†é›†çš„é’ˆå¶ç»†èŠ‚ (Points)
                const needleCount = 400;
                const needleGeo = new THREE.BufferGeometry();
                const needlePos = new Float32Array(needleCount * 3);
                for (let j = 0; j < needleCount; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = layerRadius * (0.7 + Math.random() * 0.4);
                    const h = (Math.random() - 0.5) * layerHeight;
                    const currentR = r * (1 - (h + layerHeight / 2) / layerHeight);
                    needlePos[j * 3] = Math.cos(angle) * currentR;
                    needlePos[j * 3 + 1] = h;
                    needlePos[j * 3 + 2] = Math.sin(angle) * currentR;
                }
                needleGeo.setAttribute('position', new THREE.BufferAttribute(needlePos, 3));
                const needleMat = new THREE.PointsMaterial({
                    color: 0x2d5a2d,
                    size: 0.035,
                    transparent: true,
                    opacity: 0.7
                });
                const needlePoints = new THREE.Points(needleGeo, needleMat);
                needlePoints.position.y = layerY;
                treeGroup.add(needlePoints);

                // 3. å¢å¼ºéœœå†»æ•ˆæœ
                const frostCount = 60;
                const frostGeo = new THREE.BufferGeometry();
                const frostPos = new Float32Array(frostCount * 3);
                for (let j = 0; j < frostCount; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = layerRadius * (0.95 + Math.random() * 0.1);
                    const h = -layerHeight / 2 + Math.random() * 0.3;
                    frostPos[j * 3] = Math.cos(angle) * r;
                    frostPos[j * 3 + 1] = h;
                    frostPos[j * 3 + 2] = Math.sin(angle) * r;
                }
                frostGeo.setAttribute('position', new THREE.BufferAttribute(frostPos, 3));
                const frostMat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.025,
                    transparent: true,
                    opacity: 0.8
                });
                const frostPoints = new THREE.Points(frostGeo, frostMat);
                frostPoints.position.y = layerY;
                treeGroup.add(frostPoints);

                // 4. æ›´å¤šè£…é¥°çƒ
                const ballCount = 3;
                for (let b = 0; b < ballCount; b++) {
                    const angle = Math.random() * Math.PI * 2;
                    const ballRadius = 0.09 + Math.random() * 0.06;
                    const ballGeo = new THREE.SphereGeometry(ballRadius, 16, 16);
                    const ballColor = [0xff2222, 0xffd700, 0xeeeeee, 0x4444ff][Math.floor(Math.random() * 4)];
                    const ballMat = new THREE.MeshStandardMaterial({
                        color: ballColor,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const ball = new THREE.Mesh(ballGeo, ballMat);
                    const dist = layerRadius * 0.9;
                    ball.position.set(
                        Math.cos(angle) * dist,
                        layerY - 0.15,
                        Math.sin(angle) * dist
                    );
                    treeGroup.add(ball);
                }

                // 5. ä¼˜åŒ–è£…é¥°ç¯
                const lightCount = 10;
                for (let j = 0; j < lightCount; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = layerRadius * 0.8;
                    const lightGeo = new THREE.SphereGeometry(0.04, 8, 8);
                    const lightMat = new THREE.MeshBasicMaterial({
                        color: [0xff3333, 0xffcc33, 0x33ff33, 0x33ccff][Math.floor(Math.random() * 4)],
                        transparent: true,
                        opacity: 0.8
                    });
                    const light = new THREE.Mesh(lightGeo, lightMat);
                    light.position.set(
                        Math.cos(angle) * dist,
                        layerY + (Math.random() - 0.5) * 0.5,
                        Math.sin(angle) * dist
                    );
                    treeGroup.add(light);
                    treeLights.push({
                        mesh: light,
                        phase: Math.random() * Math.PI * 2,
                        speed: 1.5 + Math.random() * 2
                    });
                }
            }

            // åº•éƒ¨ç§¯é›ª
            const snowBaseGeo = new THREE.CylinderGeometry(0.6, 1.0, 0.3, 24);
            const snowBaseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1 });
            const snowBase = new THREE.Mesh(snowBaseGeo, snowBaseMat);
            snowBase.position.y = -0.4;
            treeGroup.add(snowBase);

            treeGroup.position.set(-1.6, -0.5, -1);
            overlayScene.add(treeGroup);
            overlayTree = treeGroup;
        }

        function createOverlayFire() {
            const fireGroup = new THREE.Group();

            // æœ¨æŸ´
            const logMat = new THREE.MeshStandardMaterial({ color: 0x1a0f00 }); // ç¨å¾®è°ƒäº®ä¸€ç‚¹æœ¨æŸ´
            for (let i = 0; i < 8; i++) {
                const logGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8);
                const log = new THREE.Mesh(logGeo, logMat);
                log.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                log.rotation.y = (i / 8) * Math.PI * 2;
                log.position.y = 0.05;
                fireGroup.add(log);
            }

            // ç«ç„°ç²’å­
            const particleCount = 200;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                resetFireParticle(positions, colors, i);
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const pMaterial = new THREE.PointsMaterial({
                size: 0.25,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            overlayFire = new THREE.Points(particles, pMaterial);
            fireGroup.add(overlayFire);

            fireGroup.position.set(0.8, -0.5, 0.8); // ç§»å‘ä¸­å¿ƒï¼Œç¡®ä¿åœ¨çª„å±ä¸‹å¯è§
            overlayScene.add(fireGroup);
        }

        function resetFireParticle(positions, colors, i) {
            positions[i * 3] = (Math.random() - 0.5) * 0.4;
            positions[i * 3 + 1] = Math.random() * 0.4;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 0.4;

            const r = Math.random();
            if (r < 0.7) {
                // æ©™çº¢è‰²
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.2 + Math.random() * 0.4;
                colors[i * 3 + 2] = 0.0;
            } else if (r < 0.9) {
                // é‡‘é»„è‰²
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                colors[i * 3 + 2] = 0.1;
            } else {
                // æ·¡æ·¡çš„ç´«è‰²/è“è‰² (é­”æ³•ç«)
                colors[i * 3] = 0.5 + Math.random() * 0.5;
                colors[i * 3 + 1] = 0.2;
                colors[i * 3 + 2] = 1.0;
            }
        }

        function createOverlaySnow() {
            const snowCount = 1000;
            const snowGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(snowCount * 3);
            const sizes = new Float32Array(snowCount);

            for (let i = 0; i < snowCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 25;
                positions[i * 3 + 1] = Math.random() * 15;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 25;
                sizes[i] = 0.02 + Math.random() * 0.08;
            }

            snowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            snowGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.06,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            overlaySnow = new THREE.Points(snowGeo, snowMat);
            overlayScene.add(overlaySnow);
        }

        function animateOverlay() {
            requestAnimationFrame(animateOverlay);

            const time = Date.now() * 0.001;

            // æå…‰åŠ¨ç”»
            if (overlayAurora) {
                overlayAurora.children.forEach((aurora, i) => {
                    const positions = aurora.geometry.attributes.position.array;
                    for (let j = 0; j < positions.length; j += 3) {
                        const x = positions[j];
                        const z = positions[j + 2];
                        positions[j + 1] = 10 + Math.sin(time * 0.5 + x * 0.1 + i) * 1.5 + Math.cos(time * 0.3 + z * 0.1) * 1.5;
                    }
                    aurora.geometry.attributes.position.needsUpdate = true;
                    aurora.material.opacity = 0.1 + Math.sin(time * 0.2 + i) * 0.05;
                });
            }

            // è£…é¥°ç¯é—ªçƒ
            treeLights.forEach(light => {
                light.mesh.material.opacity = 0.4 + Math.sin(time * light.speed + light.phase) * 0.4;
                const scale = 0.8 + Math.sin(time * light.speed + light.phase) * 0.2;
                light.mesh.scale.set(scale, scale, scale);
            });

            // ç«ç„°ä¸çƒŸé›¾åŠ¨ç”»
            if (overlayFire) {
                const positions = overlayFire.geometry.attributes.position.array;
                const colors = overlayFire.geometry.attributes.color.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    // æ›´åŠ æ¸©å’Œçš„ä¸Šå‡é€Ÿåº¦
                    const h = positions[i * 3 + 1];
                    const speed = h < 0.5 ? 0.008 + Math.random() * 0.01 : 0.015 + Math.random() * 0.015;
                    positions[i * 3 + 1] += speed;

                    // æ‘‡æ‘†æ•ˆæœ - éšé«˜åº¦å¢åŠ æ‘‡æ‘†å¹…åº¦
                    const swayAmplitude = h * 0.08;
                    positions[i * 3] += Math.sin(time * 3 + h * 2 + i) * swayAmplitude * 0.1;
                    positions[i * 3 + 2] += Math.cos(time * 3 + h * 2 + i) * swayAmplitude * 0.1;

                    // é¢œè‰²ä¸ç”Ÿå‘½å‘¨æœŸï¼šåº•éƒ¨æ˜äº®ç«ç„° -> ä¸­éƒ¨æš—çº¢ -> é¡¶éƒ¨ç°è‰²çƒŸé›¾
                    if (h < 0.7) {
                        // ç«ç„°éƒ¨åˆ†
                        const fireLife = 1.0 - (h / 0.7);
                        colors[i * 3] = 1.0; // R
                        colors[i * 3 + 1] = 0.3 + fireLife * 0.7; // G
                        colors[i * 3 + 2] = fireLife * 0.3; // B
                    } else {
                        // çƒŸé›¾éƒ¨åˆ†
                        const smokeLife = 1.0 - ((h - 0.7) / 1.3);
                        const grey = 0.2 * smokeLife;
                        colors[i * 3] = grey;
                        colors[i * 3 + 1] = grey;
                        colors[i * 3 + 2] = grey;
                    }

                    // é‡ç½®ï¼šé«˜åº¦è¾¾åˆ°ä¸Šé™æˆ–éšæœºæ¶ˆå¤±
                    if (h > 2.0 || (h > 1.0 && Math.random() < 0.01)) {
                        positions[i * 3 + 1] = 0;
                        positions[i * 3] = (Math.random() - 0.5) * 0.25;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 0.25;
                    }
                }
                overlayFire.geometry.attributes.position.needsUpdate = true;
                overlayFire.geometry.attributes.color.needsUpdate = true;
            }

            // é›ªèŠ±åŠ¨ç”»
            if (overlaySnow) {
                const positions = overlaySnow.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 1] -= 0.02 + Math.random() * 0.02; // ä¸‹è½
                    positions[i * 3] += Math.sin(time + i) * 0.005; // å·¦å³æ™ƒåŠ¨

                    if (positions[i * 3 + 1] < -1) {
                        positions[i * 3 + 1] = 12;
                    }
                }
                overlaySnow.geometry.attributes.position.needsUpdate = true;
            }

            // ç«å…‰é—ªçƒ
            const fireLight = overlayScene.children.find(child => child.isPointLight);
            if (fireLight) {
                fireLight.intensity = 2.5 + Math.sin(time * 12) * 1.0 + Math.random() * 0.5;
            }

            // å¾®å¼±çš„ç›¸æœºæŠ–åŠ¨å¢åŠ å†™å®æ„Ÿ
            overlayCamera.position.x = Math.sin(time * 0.5) * 0.1;
            overlayCamera.position.y = 2 + Math.cos(time * 0.3) * 0.05;
            overlayCamera.lookAt(0, 1, 0);

            overlayRenderer.render(overlayScene, overlayCamera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            if (overlayRenderer) {
                overlayCamera.aspect = window.innerWidth / window.innerHeight;
                overlayCamera.updateProjectionMatrix();
                overlayRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // å¯†ç é”é€»è¾‘
        const passwordOverlay = document.getElementById('password-overlay');
        const passwordInput = document.getElementById('password-input');
        const passwordSubmit = document.getElementById('password-submit');
        const passwordError = document.getElementById('password-error');
        const passwordContainer = document.querySelector('.password-container');

        // åˆå§‹åŒ–
        initOverlay3D();
        animateOverlay();

        function checkPassword() {
            const password = passwordInput.value;
            if (password === '19950712') {
                // å˜å½¢æˆçˆ±å¿ƒ
                passwordContainer.classList.add('morph-to-heart');
                passwordInput.blur();

                // å»¶è¿Ÿç§»é™¤é®ç½©
                setTimeout(() => {
                    passwordOverlay.classList.add('unlocked');
                    setTimeout(() => {
                        passwordOverlay.style.display = 'none';
                        // è§£é”ååœæ­¢ 3D æ¸²æŸ“ä»¥èŠ‚çœæ€§èƒ½
                        if (overlayRenderer) {
                            overlayRenderer.dispose();
                            overlayContainer.innerHTML = '';
                        }
                    }, 1200);
                }, 1000);
            } else {
                passwordError.classList.add('show');
                passwordInput.value = '';
                passwordInput.focus();

                passwordInput.style.animation = 'shake 0.5s ease-in-out';
                setTimeout(() => {
                    passwordInput.style.animation = '';
                }, 500);

                setTimeout(() => {
                    passwordError.classList.remove('show');
                }, 3000);
            }
        }

        if (passwordSubmit) {
            passwordSubmit.addEventListener('click', checkPassword);
            passwordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') checkPassword();
            });
        }

        // æ·»åŠ æŠ–åŠ¨åŠ¨ç”»çš„ CSS
        const shakeStyle = document.createElement('style');
        shakeStyle.textContent = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-10px); }
                75% { transform: translateX(10px); }
            }
        `;
        document.head.appendChild(shakeStyle);

        animate();
    </script>
</body>

</html>